
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>is: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/goloop/is/account.go (100.0%)</option>
				
				<option value="file1">github.com/goloop/is/bank_card.go (100.0%)</option>
				
				<option value="file2">github.com/goloop/is/bank_iban.go (90.6%)</option>
				
				<option value="file3">github.com/goloop/is/code.go (91.2%)</option>
				
				<option value="file4">github.com/goloop/is/email.go (100.0%)</option>
				
				<option value="file5">github.com/goloop/is/geo.go (100.0%)</option>
				
				<option value="file6">github.com/goloop/is/hash.go (100.0%)</option>
				
				<option value="file7">github.com/goloop/is/is.go (100.0%)</option>
				
				<option value="file8">github.com/goloop/is/network.go (100.0%)</option>
				
				<option value="file9">github.com/goloop/is/number.go (100.0%)</option>
				
				<option value="file10">github.com/goloop/is/phone.go (100.0%)</option>
				
				<option value="file11">github.com/goloop/is/string.go (97.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package is

import (
        "regexp"
        "strings"
        "unicode/utf8"
)

// Regular expressions for nickname validation
var (
        // Unicode regex: Allows Unicode letters (\p{L}), numbers (\p{N}),
        // and underscores (_), 1 to 15 characters.
        unicodeNicknameRegex = regexp.MustCompile(`^[\p{L}\p{N}_]{1,15}$`)

        // ASCII regex: Allows ASCII letters (A-Za-z), numbers (0-9),
        // and underscores (_), 1 to 15 characters.
        asciiNicknameRegex = regexp.MustCompile(`^[A-Za-z0-9_]{1,15}$`)
)

// Nickname checks if the provided string is a valid nickname.
//
// In non-strict mode (default), it allows Unicode letters, numbers,
// and underscores, and the length must be within 1 to 15 characters.
// This is useful when validating user input for account creation or
// profile updates in international contexts.
//
// In strict mode, activated by passing `true` as the optional parameter,
// it only allows ASCII letters, numbers, and underscores, within the same
// length constraints.
//
// Example usage:
//
//        nickname := "User123"
//
//        if is.Nickname(nickname) {
//            fmt.Println("Nickname is valid (non-strict mode)!")
//        } else {
//            fmt.Println("Invalid nickname!")
//        }
//
//        if is.Nickname(nickname, true) {
//            fmt.Println("Nickname is valid (strict mode)!")
//        } else {
//            fmt.Println("Invalid nickname in strict mode!")
//        }
func Nickname(nickname string, strict ...bool) bool <span class="cov8" title="1">{
        // Trim spaces from the beginning and end of the nickname.
        nickname = strings.TrimSpace(nickname)

        // Check the length in characters (runes).
        length := utf8.RuneCountInString(nickname)
        if length &lt; 1 || length &gt; 15 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Determine if strict mode is enabled.
        <span class="cov8" title="1">isStrict := len(strict) &gt; 0 &amp;&amp; strict[0]

        // Select the appropriate regex based on the mode.
        var regex *regexp.Regexp
        if isStrict </span><span class="cov8" title="1">{
                regex = asciiNicknameRegex
        }</span> else<span class="cov8" title="1"> {
                regex = unicodeNicknameRegex
        }</span>

        <span class="cov8" title="1">return regex.MatchString(nickname)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package is

import (
        "regexp"
        "strings"
        "unicode"
)

var (
        // The anyCreditCard is a regular expression for matching any credit card.
        anyCreditCard = regexp.MustCompile(`^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14})$`)

        // Visa is a regular expression for matching Visa bank card.
        Visa = regexp.MustCompile(`^4[0-9]{12}(?:[0-9]{3})?$`)

        // MasterCard is a regular expression for matching MasterCard bank card.
        MasterCard = regexp.MustCompile(`^5[1-5][0-9]{14}$`)

        // AmericanExpress is a regular expression for matching
        // American Express bank card.
        AmericanExpress = regexp.MustCompile(`^3[47][0-9]{13}$`)

        // DiscoverCard is a regular expression for matching
        // Discover Card bank card.
        DiscoverCard = regexp.MustCompile(`^6(?:011\d{12}|5\d{14}|4[4-9]\d{13}|22(?:1(?:2[6-9]|[3-9]\d)|[2-8]\d{2}|9(?:[01]\d|2[0-5]))\d{10})$`)

        // DCI is a regular expression for matching DCI bank card.
        DCI = regexp.MustCompile(`^3(?:0[0-5]|[68][0-9])[0-9]{11}$`)

        // UnionPay is a regular expression for matching UnionPay bank card.
        UnionPay = regexp.MustCompile("^62[0-5]\\d{13,16}$")

        // JCB is a regular expression for matching JCB bank card.
        JCB = regexp.MustCompile(`^(?:2131|1800|35[0-9]{3})[0-9]{11}$`)

        // Argencard is a regular expression for matching Argencard bank card.
        Argencard = regexp.MustCompile(`^501105\d{10}$`)

        // Cabal is a regular expression for matching Cabal bank card.
        Cabal = regexp.MustCompile(`^6042(0[1-9]|10|1[1-9])\d{6}$`)

        // Cencosud is a regular expression for matching Cencosud bank card.
        Cencosud = regexp.MustCompile(`^603493\d{10}$`)

        // ChinaUnionPay is a regular expression for matching
        // China UnionPay bank card.
        ChinaUnionPay = regexp.MustCompile(`^62[0-9]{14,17}$`)

        // DinersClubCarteBlanche is a regular expression for matching
        // Diners Club Carte Blanche bank card.
        DinersClubCarteBlanche = regexp.MustCompile(`^30[0-5][0-9]{11}$`)

        // DinersClubInternational is a regular expression for matching
        // Diners Club International bank card.
        DinersClubInternational = regexp.MustCompile(`^36[0-9]{12}$`)

        // DinersClubUSAndCanada is a regular expression for matching
        // Diners Club US &amp; Canada bank card.
        DinersClubUSAndCanada = regexp.MustCompile(`^5[45][0-9]{14}$`)

        // DinersClub is a regular expression for matching Diners Club bank card.
        DinersClub = regexp.MustCompile(`^3(?:0[0-5]|[68][0-9])[0-9]{11}$`)

        // InstaPayment is a regular expression for matching
        // InstaPayment bank card.
        InstaPayment = regexp.MustCompile(`^63[7-9][0-9]{13}$`)

        // Laser is a regular expression for matching Laser bank card.
        Laser = regexp.MustCompile(`^(6304|670[69]|6771)[0-9]{12,15}$`)

        // Maestro is a regular expression for matching Maestro bank card.
        Maestro = regexp.MustCompile(`^(5018|5020|5038|6304|6759|676[1-3])[0-9]{8,15}$`)

        // VisaElectron is a regular expression for matching
        // Visa Electron bank card.
        VisaElectron = regexp.MustCompile(`^(4026|417500|4508|4844|491[37])[0-9]{12}$`)

        // Dankort is a regular expression for matching Dankort bank card.
        Dankort = regexp.MustCompile(`^(5019)[0-9]{12}$`)

        // RuPay is a regular expression for matching RuPay bank card.
        RuPay = regexp.MustCompile(`^(508[5-9][0-9]{1}|60698|60699|607[0-8][0-9]{1}|6079[0-7]|60798[0-4]|608[0-4][0-9]{1}|608500)[0-9]{6,9}$`)

        // InterPayment is a regular expression for matching
        // InterPayment bank card.
        InterPayment = regexp.MustCompile(`^636[0-9]{12,15}$`)

        // Troy is a regular expression for matching Troy bank card.
        Troy = regexp.MustCompile(`^9792[0-9]{12}$`)

        // MIR is a regular expression for matching MIR bank card.
        MIR = regexp.MustCompile(`^220[0-9]{13}$`)

        // UATP is a regular expression for matching UATP bank card.
        UATP = regexp.MustCompile(`^1[0-9]{14}$`)

        // Hipercard is a regular expression for matching Hipercard bank card.
        Hipercard = regexp.MustCompile(`^(606282\d{10}(\d{3})?)|(3841\d{02}\d{10})$`)

        // Naranja is a regular expression for matching Naranja bank card.
        Naranja = regexp.MustCompile(`^589562\d{10}$`)

        // TarjetaShopping is a regular expression for matching
        // Tarjeta Shopping bank card.
        TarjetaShopping = regexp.MustCompile(`^603488\d{10}$`)

        // ELO is a regular expression for matching ELO bank card.
        ELO = regexp.MustCompile(`^(401178|401179|431274|438935|451416|457393|457631|457632|504175|627780|636297|636368|636369)\d{10}$`)
)

// BankCard validates a bank card number based on provided card types.
// If no type is given, it checks against any type.
//
// BankCard uses Luhn algorithm to validate the card number
// and tests as Credit Card and Debit Card.
//
// Example usage:
//
//        is.BankCard("4111111111111111")
//        // Output: true
//        // As it's a valid card number, checked against any type.
//
//        is.BankCard("4111111111111111", is.MasterCard)
//        // Output: false
//        // It's a valid card but not of type MasterCard.
//
//        is.BankCard("4111111111111111", is.Visa)
//        // Output: true
//        // It's a valid Visa card.
//
//        is.BankCard("4111111111111111", is.Visa, is.MasterCard)
//        // Output: true
//        // It's a valid card of either Visa or MasterCard type.
//
//        is.BankCard("1234567812345678")
//        // Output: false
//        // Not a valid card number.
func BankCard(str string, kinds ...*regexp.Regexp) bool <span class="cov8" title="1">{
        if len(kinds) == 0 </span><span class="cov8" title="1">{
                return cardChecker(str, anyCreditCard)
        }</span>

        <span class="cov8" title="1">for _, kind := range kinds </span><span class="cov8" title="1">{
                if cardChecker(str, kind) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// The cardChecker checks whether a string matches a given card regex and
// validates its checksum according to the Luhn algorithm.
// It's used internally in the BankCard and CreditCard functions.
// This function isn't exported, so it can't be used outside the 'is' package.
//
// Here's how it works:
//  1. It ignores spaces and hyphens in the input string.
//  2. It calculates the Luhn checksum of the card number.
//  3. It checks that the sum of the digits is a multiple of 10.
//  4. It validates the card number against the provided regular expression.
//
// It returns true if all checks pass, and false otherwise.
func cardChecker(n string, regex *regexp.Regexp) bool <span class="cov8" title="1">{
        // Remove spaces and hyphens from the input string.
        clean := strings.Map(func(r rune) rune </span><span class="cov8" title="1">{
                if r == ' ' || r == '-' </span><span class="cov8" title="1">{
                        return -1 // remove the character
                }</span>
                <span class="cov8" title="1">return r</span>
        }, n)

        <span class="cov8" title="1">var sum int
        parity := len(clean) % 2

        for i, r := range clean </span><span class="cov8" title="1">{
                // Check if the character is a digit.
                if !unicode.IsDigit(r) </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">d := int(r - '0')
                if i%2 == parity </span><span class="cov8" title="1">{
                        d *= 2
                        if d &gt; 9 </span><span class="cov8" title="1">{
                                d -= 9
                        }</span>
                }

                <span class="cov8" title="1">sum += d</span>
        }

        // Check if the sum is a multiple of 10.
        <span class="cov8" title="1">if sum%10 != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check the regular expression match.
        <span class="cov8" title="1">if !regex.MatchString(clean) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package is

/* IBAN DATA
Albania*AL*false*28*false*true*AL35202111090000000001234567
Andorra*AD*true*24*false*true*AD1400080001001234567890
Azerbaijan*AZ*false*28*false*false*AZ77VTBA00000000001234567890
Bahrain*BH*false*22*false*false*BH02CITI00001077181611
Brazil*BR*false*29*false*true*BR1500000000000010932840814P2
Bulgaria*BG*true*22*false*true*BG18RZBB91550123456789
Cyprus*CY*true*28*false*true*CY21002001950000357001234567
Dominican Republic*DO*false*28*false*false*DO22ACAU00000000000123456789
Egypt*EG*false*29*false*false*EG800002000156789012345180002
Georgia*GE*false*22*false*false*GE60NB0000000123456789
Gibraltar*GI*true*23*false*true*GI56XAPO000001234567890
Greece*GR*true*27*false*true*GR9608100010000001234567890
Guatemala*GT*false*28*false*false*GT20AGRO00000000001234567890
Jordan*JO*false*30*false*true*JO71CBJO0000000000001234567890
Kazakhstan*KZ*false*20*false*false*KZ244350000012344567
Kuwait*KW*false*30*false*false*KW81CBKU0000000000001234560101
Latvia*LV*true*21*false*false*LV97HABA0012345678910
Lebanon*LB*false*28*false*false*LB92000700000000123123456123
Lithuania*LT*true*20*false*true*LT601010012345678901
Luxembourg*LU*true*20*false*false*LU120010001234567891
Malta*MT*true*31*false*true*MT31MALT01100000000000000000123
Mauritius*MU*false*30*false*true*MU43BOMM0101123456789101000MUR
Moldova*MD*false*24*false*false*MD21EX000000000001234567
Pakistan*PK*false*24*false*false*PK36SCBL0000001123456702
Palestine*PS*false*29*false*false*PS92PALS000000000400123456702
Qatar*QA*false*29*false*false*QA54QNBA000000000000693123456
Romania*RO*true*24*false*false*RO66BACX0000001234567890
Saint Lucia*LC*false*32*false*false*LC14BOSL123456789012345678901234
Sao Tome and Principe*ST*false*25*false*false*ST23000200000289355710148
Saudi Arabia*SA*false*24*false*false*SA4420000001234567891234
Turkey*TR*false*26*false*true*TR320010009999901234567890
United Arab Emirates*AE*false*23*false*false*AE460090000000123456789
Holy See*VA*true*22*false*false*VA59001123000012345678
Virgin Islands, British*VG*false*24*false*false*VG07ABVI0000000123456789
Ukraine*UA*false*29*false*true*UA903052992990004149123456789
Seychelles*SC*false*31*false*false*SC74MCBL01031234567890123456USD
Iraq*IQ*false*23*false*false*IQ20CBIQ861800101010500
Belarus*BY*false*28*false*false*BY86AKBB10100000002966000000
El Salvador*SV*false*28*false*false*SV43ACAT00000000000000123123
Libya*LY*false*25*false*false*LY38021001000000123456789
Sudan*SD*false*18*false*false*SD8811123456789012
Burundi*BI*false*27*false*false*BI4210000100010000332045181
Djibouti*DJ*false*27*false*false*DJ2110002010010409943020008
Somalia*SO*false*23*false*true*SO061000001123123456789
Austria*AT*true*20*true*true*AT483200000012345864
Belgium*BE*true*16*true*true*BE71096123456769
Bosnia and Herzegovina*BA*false*20*true*true*BA393385804800211234
Costa Rica*CR*false*22*true*false*CR23015108410026012345
Croatia*HR*true*21*true*false*HR1723600001101234565
Czech Republic*CZ*true*24*true*false*CZ5508000000001234567899
Faroe Islands*FO*false*18*true*true*FO9264600123456789
Greenland*GL*false*18*true*true*GL8964710123456789
Denmark*DK*true*18*true*true*DK9520000123456789
Estonia*EE*true*20*true*true*EE471000001020145685
Finland*FI*true*18*true*true*FI1410093000123458
France*FR*true*27*true*true*FR7630006000011234567890189
Germany*DE*true*22*true*true*DE75512108001245126199
Hungary*HU*true*28*true*true*HU93116000060000000012345676
Iceland*IS*true*26*true*true*IS750001121234563108962099
Ireland*IE*true*22*true*true*IE64IRCE92050112345678
Israel*IL*false*23*true*true*IL170108000000012612345
Italy*IT*true*27*true*true*IT60X0542811101000000123456
Kosovo*XK*false*20*true*true*XK051212012345678906
Liechtenstein*LI*true*21*true*true*LI7408806123456789012
North Macedonia*MK*false*19*true*false*MK07200002785123453
Mauritania*MR*false*27*true*true*MR1300020001010000123456753
Monaco*MC*true*27*true*true*MC5810096180790123456789085
Montenegro*ME*false*22*true*false*ME25505000012345678951
Netherlands*NL*true*18*true*true*NL02ABNA0123456789
Norway*NO*true*15*true*true*NO8330001234567
Poland*PL*true*28*true*true*PL10105000997603123456789123
Portugal*PT*true*25*true*true*PT50002700000001234567833
San Marino*SM*true*27*true*true*SM76P0854009812123456789123
Serbia*RS*false*22*true*false*RS35105008123123123173
Slovakia*SK*true*24*true*false*SK8975000000000012345671
Slovenia*SI*true*19*true*true*SI56192001234567892
Spain*ES*true*24*true*true*ES7921000813610123456789
Sweden*SE*true*24*true*true*SE7280000810340009783242
Switzerland*CH*true*21*true*true*CH5604835012345678009
Timor-Leste*TL*false*23*true*false*TL380010012345678910106
Tunisia*TN*false*24*true*true*TN5904018104004942712345
United Kingdom*GB*true*22*true*true*GB33BUKB20201555555555
Russia*RU*false*33*true*true*RU0204452560040702810412345678901
*/

import (
        "fmt"
        "math/big"
        "strings"

        "github.com/goloop/g"
)

var ibanLenPatterns = map[string]int{
        "AL": 28, "AD": 24, "AZ": 28, "BH": 22, "BR": 29, "BG": 22, "CY": 28,
        "DO": 28, "EG": 29, "GE": 22, "GI": 23, "GR": 27, "GT": 28, "JO": 30,
        "KZ": 20, "KW": 30, "LV": 21, "LB": 28, "LT": 20, "LU": 20, "MT": 31,
        "MU": 30, "MD": 24, "PK": 24, "PS": 29, "QA": 29, "RO": 24, "LC": 32,
        "ST": 25, "SA": 24, "TR": 26, "AE": 23, "VA": 22, "VG": 24, "UA": 29,
        "SC": 31, "IQ": 23, "BY": 28, "SV": 28, "LY": 25, "SD": 18, "BI": 27,
        "DJ": 27, "SO": 23, "AT": 20, "BE": 16, "BA": 20, "CR": 22, "HR": 21,
        "CZ": 24, "FO": 18, "GL": 18, "DK": 18, "EE": 20, "FI": 18, "FR": 27,
        "DE": 22, "HU": 28, "IS": 26, "IE": 22, "IL": 23, "IT": 27, "XK": 20,
        "LI": 21, "MK": 19, "MR": 27, "MC": 27, "ME": 22, "NL": 18, "NO": 15,
        "PL": 28, "PT": 25, "SM": 27, "RS": 22, "SK": 24, "SI": 19, "ES": 24,
        "SE": 24, "CH": 21, "TL": 23, "TN": 24, "GB": 22, "RU": 33,
}

// letterToNumberCache is a cache for the mapLetterToNumber function.
// Is initialized in init().
var letterToNumberCache = make(map[rune]int)

// The mapLetterToNumber converts a letter to a number as per IBAN
// specifications. For example, 'A' is mapped to 10, 'B' to 11 etc.
func mapLetterToNumber(letter rune) int <span class="cov8" title="1">{
        if value, ok := letterToNumberCache[letter]; ok </span><span class="cov8" title="1">{
                return value
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// CalculateIBANChecksum calculates the checksum of an IBAN as per the
// specifications. This is used to verify the validity of an IBAN number.
func CalculateIBANChecksum(iban string) *big.Int <span class="cov8" title="1">{
        mapped := ""

        // Cycle through each IBAN character.
        for _, letter := range iban </span><span class="cov8" title="1">{
                if letter &gt;= 'A' &amp;&amp; letter &lt;= 'Z' </span><span class="cov8" title="1">{
                        // Convert the letter to a number.
                        mapped += fmt.Sprintf("%d", mapLetterToNumber(letter))
                }</span> else<span class="cov8" title="1"> if letter &gt;= '0' &amp;&amp; letter &lt;= '9' </span><span class="cov8" title="1">{
                        // Append digits as they are.
                        mapped += string(letter)
                }</span> else<span class="cov0" title="0"> {
                        // Invalid character found.
                        return big.NewInt(-1)
                }</span>
        }

        <span class="cov8" title="1">number := new(big.Int)
        _, ok := number.SetString(mapped, 10)
        if !ok </span><span class="cov0" title="0">{
                // Error converting string to number.
                return big.NewInt(-1)
        }</span>

        // Return the remainder from division by 97.
        <span class="cov8" title="1">return new(big.Int).Mod(number, big.NewInt(97))</span>
}

// Iban checks if a given IBAN (International Bank Account Number)
// has a valid format. If the input matches the pattern for the corresponding
// country and passes the checksum validation, the function returns true.
//
// By default, the function operates in non-strict mode. In non-strict mode:
//   - Spaces are removed from the input string.
//   - The input string is converted to uppercase.
//
// This allows the function to validate IBANs that may have spaces
// or lowercase letters.
//
// If the optional parameter `strict` is provided and set to true,
// the function operates in strict mode:
//   - The input string is not modified.
//   - Any deviations from the standard IBAN format (such as spaces,
//     lowercase letters, or special characters) will cause the function
//     to return false.
//
// Example usage:
//
//        // Non-strict mode (default):
//        is.Iban("GB82 WEST 1234 5698 7654 32")    // Returns: true
//        is.Iban("ua903052992990004149123456789")  // Returns: true
//
//        // Strict mode:
//        is.Iban("GB82WEST12345698765432", true)       // Returns: true
//        is.Iban("GB82 WEST 1234 5698 7654 32", true)  // Returns: false
//        is.Iban("ua903052992990004149123456789", true)// Returns: false (lowercase)
//
// Note:
//   - In strict mode, you should ensure that the input IBAN is properly
//     formatted:
//   - No spaces or special characters.
//   - All letters are uppercase.
//
// - You can preprocess the IBAN before validation if needed.
//
// For example, to validate an IBAN with spaces in strict mode:
//
//        iban := "GB82 WEST 1234 5698 7654 32"
//        iban = strings.ReplaceAll(iban, " ", "")
//        iban = strings.ToUpper(iban)
//        is.Iban(iban, true) // Returns: true
func Iban(iban string, strict ...bool) bool <span class="cov8" title="1">{
        if !g.All(strict...) </span><span class="cov8" title="1">{
                // Remove spaces and convert to uppercase.
                iban = strings.ToUpper(strings.ReplaceAll(iban, " ", ""))
        }</span> else<span class="cov8" title="1"> {
                // In strict mode, check for invalid characters.
                for _, ch := range iban </span><span class="cov8" title="1">{
                        if ch &lt; '0' || ch &gt; '9' &amp;&amp; ch &lt; 'A' || ch &gt; 'Z' </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                // Convert to uppercase for checksum calculation.
                <span class="cov8" title="1">iban = strings.ToUpper(iban)</span>
        }

        // IBAN must be at least 4 characters long to extract
        // country code and checksum.
        <span class="cov8" title="1">if len(iban) &lt; 4 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if the length matches the expected length for the country.
        <span class="cov8" title="1">countryCode := iban[0:2]
        if l, ok := ibanLenPatterns[countryCode]; !ok || l != len(iban) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Move the first four characters to the end of the string.
        <span class="cov8" title="1">rearrangedIban := iban[4:] + iban[0:4]

        // Calculate the checksum
        remainder := CalculateIBANChecksum(rearrangedIban)
        if remainder.Sign() &lt; 0 </span><span class="cov0" title="0">{
                // Invalid character encountered in checksum calculation.
                return false
        }</span>
        <span class="cov8" title="1">return remainder.Cmp(big.NewInt(1)) == 0</span>
}

// IBAN is a synonym for the Iban function. This naming approach adheres
// to Go's conventions for abbreviations in function names. The function
// takes an IBAN (International Bank Account Number) as a string parameter
// and returns a boolean value indicating whether the input IBAN is valid
// according to the defined pattern and checksum.
func IBAN(iban string, strict ...bool) bool <span class="cov8" title="1">{
        return Iban(iban, strict...)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package is

import (
        "fmt"
        "regexp"
        "strings"
        "unicode"

        "github.com/goloop/g"
)

var (
        // selectorStrictRegex is the regular expression for a valid CSS
        // selector in strict mode.
        selectorStrictRegex = regexp.MustCompile(`^[a-zA-Z_-][a-zA-Z\d_-]*$`)

        // selectorRegex is the regular expression for a valid CSS
        // selector in non-strict mode.
        selectorRegex = regexp.MustCompile(`^(#|\.)?[a-zA-Z_-][a-zA-Z\d_-]*$`)

        // ErrLanguageNotSupported indicates that the specified
        // programming language is not supported.
        ErrLanguageNotSupported = func(lang string) error <span class="cov8" title="1">{
                return fmt.Errorf("programming language '%s' is not supported", lang)
        }</span>
)

// reservedWords contains reserved keywords for various programming languages.
var reservedWords = map[string]map[string]struct{}{
        "python": {
                "and": {}, "as": {}, "assert": {}, "async": {}, "await": {},
                "break": {}, "class": {}, "continue": {}, "def": {}, "del": {},
                "elif": {}, "else": {}, "except": {}, "False": {}, "finally": {},
                "for": {}, "from": {}, "global": {}, "if": {}, "import": {},
                "in": {}, "is": {}, "lambda": {}, "None": {}, "nonlocal": {},
                "not": {}, "or": {}, "pass": {}, "raise": {}, "return": {},
                "True": {}, "try": {}, "while": {}, "with": {}, "yield": {},
                "match": {}, "case": {}, "type": {}, "print": {},
        },

        "javascript": {
                "abstract": {}, "arguments": {}, "await": {}, "boolean": {},
                "break": {}, "byte": {}, "case": {}, "catch": {}, "char": {},
                "class": {}, "const": {}, "continue": {}, "debugger": {},
                "default": {}, "delete": {}, "do": {}, "double": {}, "else": {},
                "enum": {}, "eval": {}, "export": {}, "extends": {}, "false": {},
                "final": {}, "finally": {}, "float": {}, "for": {}, "function": {},
                "goto": {}, "if": {}, "implements": {}, "import": {}, "in": {},
                "instanceof": {}, "int": {}, "interface": {}, "let": {}, "long": {},
                "native": {}, "new": {}, "null": {}, "package": {}, "private": {},
                "protected": {}, "public": {}, "return": {}, "short": {},
                "static": {}, "super": {}, "switch": {}, "synchronized": {},
                "this": {}, "throw": {}, "throws": {}, "transient": {}, "true": {},
                "try": {}, "typeof": {}, "var": {}, "void": {}, "volatile": {},
                "while": {}, "with": {}, "yield": {}, "async": {},
        },

        "typescript": {
                "any": {}, "as": {}, "async": {}, "await": {}, "boolean": {},
                "break": {}, "case": {}, "catch": {}, "class": {}, "const": {},
                "constructor": {}, "continue": {}, "debugger": {}, "declare": {},
                "default": {}, "delete": {}, "do": {}, "else": {}, "enum": {},
                "export": {}, "extends": {}, "false": {}, "finally": {}, "for": {},
                "from": {}, "function": {}, "get": {}, "if": {}, "implements": {},
                "import": {}, "in": {}, "infer": {}, "instanceof": {}, "interface": {},
                "is": {}, "keyof": {}, "let": {}, "module": {}, "namespace": {},
                "never": {}, "new": {}, "null": {}, "number": {}, "object": {},
                "package": {}, "private": {}, "protected": {}, "public": {},
                "readonly": {}, "require": {}, "return": {}, "set": {}, "static": {},
                "string": {}, "super": {}, "switch": {}, "this": {}, "throw": {},
                "true": {}, "try": {}, "type": {}, "typeof": {}, "undefined": {},
                "unique": {}, "unknown": {}, "var": {}, "void": {}, "while": {},
                "with": {}, "yield": {},
        },

        "go": {
                "break": {}, "case": {}, "chan": {}, "const": {}, "continue": {},
                "default": {}, "defer": {}, "else": {}, "fallthrough": {}, "for": {},
                "func": {}, "go": {}, "goto": {}, "if": {}, "import": {},
                "interface": {}, "map": {}, "package": {}, "range": {}, "return": {},
                "select": {}, "struct": {}, "switch": {}, "type": {}, "var": {},
        },

        "rust": {
                "as": {}, "break": {}, "const": {}, "continue": {}, "crate": {},
                "dyn": {}, "else": {}, "enum": {}, "extern": {}, "false": {},
                "fn": {}, "for": {}, "if": {}, "impl": {}, "in": {}, "let": {},
                "loop": {}, "match": {}, "mod": {}, "move": {}, "mut": {}, "pub": {},
                "ref": {}, "return": {}, "self": {}, "Self": {}, "static": {},
                "struct": {}, "super": {}, "trait": {}, "true": {}, "type": {},
                "unsafe": {}, "use": {}, "where": {}, "while": {}, "async": {},
                "await": {}, "try": {}, "union": {},
        },

        "cpp": {
                "alignas": {}, "alignof": {}, "and": {}, "and_eq": {}, "asm": {},
                "auto": {}, "bitand": {}, "bitor": {}, "bool": {}, "break": {},
                "case": {}, "catch": {}, "char": {}, "char8_t": {}, "char16_t": {},
                "char32_t": {}, "class": {}, "compl": {}, "concept": {}, "const": {},
                "consteval": {}, "constexpr": {}, "constinit": {}, "const_cast": {},
                "continue": {}, "co_await": {}, "co_return": {}, "co_yield": {},
                "decltype": {}, "default": {}, "delete": {}, "do": {}, "double": {},
                "dynamic_cast": {}, "else": {}, "enum": {}, "explicit": {},
                "export": {}, "extern": {}, "false": {}, "float": {}, "for": {},
                "friend": {}, "goto": {}, "if": {}, "inline": {}, "int": {},
                "long": {}, "mutable": {}, "namespace": {}, "new": {}, "noexcept": {},
                "not": {}, "not_eq": {}, "nullptr": {}, "operator": {}, "or": {},
                "or_eq": {}, "private": {}, "protected": {}, "public": {},
                "register": {}, "reinterpret_cast": {}, "requires": {}, "return": {},
                "short": {}, "signed": {}, "sizeof": {}, "static": {},
                "static_assert": {}, "static_cast": {}, "struct": {}, "switch": {},
                "template": {}, "this": {}, "thread_local": {}, "throw": {},
                "true": {}, "try": {}, "typedef": {}, "typeid": {}, "typename": {},
                "union": {}, "unsigned": {}, "using": {}, "virtual": {}, "void": {},
                "volatile": {}, "wchar_t": {}, "while": {}, "xor": {}, "xor_eq": {},
        },

        "c": {
                "auto": {}, "break": {}, "case": {}, "char": {}, "const": {},
                "continue": {}, "default": {}, "do": {}, "double": {}, "else": {},
                "enum": {}, "extern": {}, "float": {}, "for": {}, "goto": {},
                "if": {}, "inline": {}, "int": {}, "long": {}, "register": {},
                "restrict": {}, "return": {}, "short": {}, "signed": {}, "sizeof": {},
                "static": {}, "struct": {}, "switch": {}, "typedef": {}, "union": {},
                "unsigned": {}, "void": {}, "volatile": {}, "while": {}, "_Bool": {},
                "_Complex": {}, "_Imaginary": {},
                "_Alignas": {}, "_Alignof": {}, "_Atomic": {}, "_Generic": {},
                "_Noreturn": {}, "_Static_assert": {}, "_Thread_local": {},
                "#define": {}, "#include": {}, "#undef": {}, "#ifdef": {},
                "#ifndef": {}, "#if": {}, "#else": {}, "#elif": {}, "#endif": {},
                "#error": {}, "#pragma": {}, "#line": {},
                "size_t": {}, "ptrdiff_t": {}, "NULL": {}, "true": {}, "false": {},
                "stdin": {}, "stdout": {}, "stderr": {}, "errno": {}, "EOF": {},
                "int8_t": {}, "uint8_t": {}, "int16_t": {}, "uint16_t": {},
                "int32_t": {}, "uint32_t": {}, "int64_t": {}, "uint64_t": {},
                "intptr_t": {}, "uintptr_t": {}, "wchar_t": {}, "time_t": {},
                "INFINITY": {}, "NAN": {}, "INT_MAX": {}, "INT_MIN": {},
                "UINT_MAX": {}, "offsetof": {}, "va_list": {},
                "va_start": {}, "va_end": {}, "va_arg": {},
        },

        "java": {
                "abstract": {}, "assert": {}, "boolean": {}, "break": {},
                "byte": {}, "case": {}, "catch": {}, "char": {}, "class": {},
                "const": {}, "continue": {}, "default": {}, "do": {}, "double": {},
                "else": {}, "enum": {}, "extends": {}, "final": {}, "finally": {},
                "float": {}, "for": {}, "goto": {}, "if": {}, "implements": {},
                "import": {}, "instanceof": {}, "int": {}, "interface": {},
                "long": {}, "native": {}, "new": {}, "package": {}, "private": {},
                "protected": {}, "public": {}, "return": {}, "short": {},
                "static": {}, "strictfp": {}, "super": {}, "switch": {},
                "synchronized": {}, "this": {}, "throw": {}, "throws": {},
                "transient": {}, "try": {}, "void": {}, "volatile": {}, "while": {},
                "true": {}, "false": {}, "null": {}, "var": {}, "sealed": {},
                "permits": {}, "record": {}, "yield": {},
        },

        "kotlin": {
                "abstract": {}, "actual": {}, "annotation": {}, "as": {}, "break": {},
                "by": {}, "catch": {}, "class": {}, "companion": {}, "const": {},
                "constructor": {}, "continue": {}, "crossinline": {}, "data": {},
                "delegate": {}, "do": {}, "dynamic": {}, "else": {}, "enum": {},
                "expect": {}, "external": {}, "false": {}, "field": {}, "final": {},
                "finally": {}, "for": {}, "fun": {}, "get": {}, "if": {}, "import": {},
                "infix": {}, "init": {}, "inline": {}, "inner": {}, "interface": {},
                "internal": {}, "is": {}, "lateinit": {}, "noinline": {}, "null": {},
                "object": {}, "open": {}, "operator": {}, "out": {}, "override": {},
                "package": {}, "private": {}, "protected": {}, "public": {},
                "reified": {}, "return": {}, "sealed": {}, "set": {}, "super": {},
                "suspend": {}, "tailrec": {}, "this": {}, "throw": {}, "true": {},
                "try": {}, "typealias": {}, "val": {}, "var": {}, "vararg": {},
                "when": {}, "while": {}, "in": {},
        },

        "swift": {
                "any": {}, "as": {}, "associatedtype": {}, "associativity": {},
                "case": {}, "catch": {}, "class": {}, "continue": {},
                "default": {}, "defer": {}, "deinit": {}, "didSet": {}, "do": {},
                "dynamic": {}, "else": {}, "enum": {}, "extension": {},
                "false": {}, "fileprivate": {}, "final": {}, "for": {}, "func": {},
                "get": {}, "guard": {}, "if": {}, "import": {}, "in": {}, "infix": {},
                "init": {}, "inout": {}, "internal": {}, "is": {}, "lazy": {},
                "let": {}, "mutating": {}, "nil": {}, "none": {}, "nonmutating": {},
                "open": {}, "operator": {}, "optional": {}, "override": {},
                "precedence": {}, "prefix": {}, "private": {}, "protocol": {},
                "repeat": {}, "required": {}, "return": {}, "right": {}, "self": {},
                "set": {}, "static": {}, "struct": {}, "subscript": {}, "super": {},
                "switch": {}, "throw": {}, "throws": {}, "true": {}, "try": {},
                "typealias": {}, "unowned": {}, "var": {}, "weak": {}, "where": {},
                "while": {}, "willSet": {}, "break": {}, "fallthrough": {}, "left": {},
                "public": {}, "type": {}, "postfix": {}, "convenience": {},
        },

        "sql": {
                "add": {}, "all": {}, "alter": {}, "and": {}, "any": {}, "as": {},
                "asc": {}, "backup": {}, "between": {}, "by": {}, "case": {},
                "column": {}, "constraint": {}, "create": {}, "database": {},
                "delete": {}, "desc": {}, "distinct": {}, "drop": {}, "exec": {},
                "exists": {}, "foreign": {}, "from": {}, "full": {}, "group": {},
                "in": {}, "index": {}, "inner": {}, "insert": {}, "into": {}, "is": {},
                "join": {}, "key": {}, "left": {}, "like": {}, "limit": {}, "not": {},
                "null": {}, "or": {}, "order": {}, "outer": {}, "primary": {},
                "procedure": {}, "right": {}, "rownum": {}, "select": {}, "set": {},
                "table": {}, "top": {}, "truncate": {}, "union": {}, "unique": {},
                "update": {}, "values": {}, "view": {}, "where": {}, "with": {},
                "check": {}, "default": {}, "having": {},
        },

        "php": {
                "abstract": {}, "and": {}, "array": {}, "as": {}, "break": {},
                "case": {}, "catch": {}, "class": {}, "clone": {}, "const": {},
                "declare": {}, "default": {}, "die": {}, "do": {}, "echo": {},
                "elseif": {}, "empty": {}, "enddeclare": {}, "endfor": {},
                "endif": {}, "endswitch": {}, "endwhile": {}, "eval": {}, "exit": {},
                "extends": {}, "final": {}, "finally": {}, "fn": {}, "for": {},
                "function": {}, "global": {}, "goto": {}, "if": {}, "implements": {},
                "include": {}, "include_once": {}, "instanceof": {}, "insteadof": {},
                "interface": {}, "isset": {}, "list": {}, "match": {}, "namespace": {},
                "new": {}, "or": {}, "print": {}, "private": {}, "protected": {},
                "require": {}, "require_once": {}, "return": {}, "static": {},
                "throw": {}, "trait": {}, "try": {}, "unset": {}, "use": {},
                "while": {}, "xor": {}, "yield": {}, "yield from": {},
                "callable": {}, "continue": {}, "else": {}, "endforeach": {},
                "foreach": {}, "public": {}, "switch": {}, "var": {}, "true": {},
                "false": {}, "null": {},
        },

        "ruby": {
                "alias": {}, "and": {}, "begin": {}, "break": {}, "case": {},
                "def": {}, "defined?": {}, "do": {}, "else": {}, "elsif": {}, "end": {},
                "ensure": {}, "false": {}, "for": {}, "if": {}, "in": {}, "module": {},
                "next": {}, "nil": {}, "not": {}, "or": {}, "redo": {}, "rescue": {},
                "retry": {}, "return": {}, "self": {}, "super": {}, "then": {},
                "undef": {}, "unless": {}, "until": {}, "when": {}, "while": {},
                "class": {}, "true": {}, "yield": {},
        },

        "csharp": {
                "abstract": {}, "as": {}, "base": {}, "bool": {}, "break": {},
                "case": {}, "catch": {}, "char": {}, "checked": {}, "class": {},
                "continue": {}, "decimal": {}, "default": {}, "delegate": {}, "do": {},
                "double": {}, "else": {}, "enum": {}, "event": {}, "explicit": {},
                "extern": {}, "false": {}, "finally": {}, "fixed": {}, "float": {},
                "for": {}, "foreach": {}, "goto": {}, "if": {}, "implicit": {},
                "in": {}, "int": {}, "interface": {}, "internal": {}, "is": {},
                "long": {}, "namespace": {}, "new": {}, "null": {}, "object": {},
                "operator": {}, "out": {}, "override": {}, "params": {}, "private": {},
                "protected": {}, "public": {}, "readonly": {}, "ref": {}, "return": {},
                "sbyte": {}, "sealed": {}, "short": {}, "sizeof": {}, "stackalloc": {},
                "static": {}, "string": {}, "struct": {}, "switch": {}, "this": {},
                "throw": {}, "true": {}, "try": {}, "typeof": {}, "uint": {},
                "unchecked": {}, "unsafe": {}, "ushort": {}, "using": {}, "virtual": {},
                "void": {}, "volatile": {}, "while": {}, "add": {}, "alias": {},
                "ascending": {}, "async": {}, "await": {}, "by": {}, "descending": {},
                "dynamic": {}, "equals": {}, "from": {}, "get": {}, "global": {},
                "group": {}, "into": {}, "join": {}, "let": {}, "nameof": {},
                "notnull": {}, "on": {}, "orderby": {}, "partial": {}, "remove": {},
                "select": {}, "set": {}, "unmanaged": {}, "value": {}, "var": {},
                "when": {}, "where": {}, "with": {}, "yield": {}, "byte": {},
                "const": {}, "lock": {}, "ulong": {},
        },

        "html": {
                "!doctype": {}, "a": {}, "abbr": {}, "address": {}, "area": {},
                "article": {}, "aside": {}, "audio": {}, "b": {}, "base": {},
                "bdi": {}, "bdo": {}, "blockquote": {}, "body": {}, "br": {},
                "button": {}, "canvas": {}, "caption": {}, "cite": {}, "code": {},
                "col": {}, "colgroup": {}, "data": {}, "datalist": {}, "dd": {},
                "del": {}, "details": {}, "dfn": {}, "dialog": {}, "div": {},
                "dl": {}, "dt": {}, "em": {}, "embed": {}, "fieldset": {},
                "figure": {}, "footer": {}, "form": {}, "h1": {}, "h2": {}, "h3": {},
                "h4": {}, "h5": {}, "h6": {}, "head": {}, "header": {}, "hr": {},
                "html": {}, "i": {}, "iframe": {}, "img": {}, "input": {}, "ins": {},
                "kbd": {}, "label": {}, "legend": {}, "li": {}, "link": {}, "main": {},
                "map": {}, "mark": {}, "meta": {}, "meter": {}, "nav": {},
                "object": {}, "ol": {}, "optgroup": {}, "option": {}, "output": {},
                "p": {}, "param": {}, "picture": {}, "pre": {}, "progress": {}, "q": {},
                "rp": {}, "rt": {}, "ruby": {}, "s": {}, "samp": {}, "script": {},
                "section": {}, "select": {}, "small": {}, "source": {}, "span": {},
                "strong": {}, "style": {}, "sub": {}, "summary": {}, "sup": {},
                "table": {}, "tbody": {}, "td": {}, "template": {}, "textarea": {},
                "tfoot": {}, "th": {}, "thead": {}, "time": {}, "title": {}, "tr": {},
                "track": {}, "u": {}, "ul": {}, "var": {}, "video": {}, "wbr": {},
                "figcaption": {}, "noscript": {},
        },

        "css": {
                "@charset": {}, "@import": {}, "@namespace": {}, "@media": {},
                "@supports": {}, "@document": {}, "@page": {}, "@font-face": {},
                "@keyframes": {}, "@viewport": {}, "@counter-style": {},
                "@layer": {}, "@property": {}, "active": {}, "after": {}, "align": {},
                "align-content": {}, "align-items": {}, "align-self": {}, "all": {},
                "animation": {}, "appearance": {}, "attr": {}, "auto": {},
                "background": {}, "before": {}, "border": {}, "bottom": {}, "box": {},
                "break": {}, "calc": {}, "caret": {}, "checked": {}, "clear": {},
                "clip": {}, "color": {}, "column": {}, "content": {}, "counter": {},
                "cursor": {}, "direction": {}, "display": {}, "element": {},
                "enabled": {}, "filter": {}, "first": {}, "flex": {}, "float": {},
                "focus": {}, "font": {}, "gap": {}, "grid": {}, "height": {},
                "hover": {}, "hsl": {}, "hsla": {}, "if": {}, "image": {}, "import": {},
                "important": {}, "in": {}, "inherit": {}, "initial": {}, "inset": {},
                "justify": {}, "lang": {}, "last": {}, "left": {}, "line": {},
                "link": {}, "list": {}, "margin": {}, "mask": {}, "matrix": {},
                "max": {}, "media": {}, "min": {}, "mix": {}, "nth": {}, "only": {},
                "opacity": {}, "order": {}, "outline": {}, "overflow": {},
                "page": {}, "perspective": {}, "placeholder": {}, "position": {},
                "property": {}, "rgb": {}, "rgba": {}, "right": {}, "root": {},
                "rotate": {}, "scale": {}, "scroll": {}, "selection": {}, "shadow": {},
                "shape": {}, "size": {}, "skew": {}, "space": {}, "src": {},
                "step": {}, "style": {}, "supports": {}, "table": {}, "target": {},
                "text": {}, "top": {}, "transform": {}, "transition": {},
                "type": {}, "url": {}, "user": {}, "valid": {}, "var": {},
                "vertical": {}, "visibility": {}, "visited": {}, "white": {},
                "z-index": {}, "@font-feature-values": {}, "backdrop-filter": {},
                "translate": {}, "width": {}, "empty": {}, "padding": {},
        },

        "markdown": {
                "#": {}, "##": {}, "###": {}, "####": {}, "#####": {}, "######": {},
                "*": {}, "**": {}, "_": {}, "__": {}, "___": {},
                "`": {}, "``": {}, "```": {}, "~~~~": {}, "&gt;": {}, "&gt;&gt;": {},
                "-": {}, "+": {}, "1.": {}, "[": {}, "]": {}, "(": {}, ")": {},
                "{": {}, "}": {}, "!": {}, "|": {}, "\\": {}, "---": {},
                "===": {}, "***": {}, "&lt;!--": {}, "--&gt;": {},
        },

        "regex": {
                "^": {}, "$": {}, ".": {}, "*": {}, "+": {}, "?": {}, "|": {},
                "\\": {}, "(": {}, ")": {}, "[": {}, "]": {}, "{": {}, "}": {},
                "\\d": {}, "\\D": {}, "\\w": {}, "\\W": {}, "\\s": {}, "\\S": {},
                "\\b": {}, "\\B": {}, "\\n": {}, "\\r": {}, "\\t": {}, "\\f": {},
                "\\v": {}, "\\0": {}, "\\x": {}, "\\u": {}, "\\c": {}, "\\p": {},
        },

        "bash": {
                "alias": {}, "bg": {}, "bind": {}, "break": {}, "builtin": {},
                "caller": {}, "cd": {}, "command": {}, "compgen": {}, "complete": {},
                "compopt": {}, "continue": {}, "declare": {}, "dirs": {}, "disown": {},
                "echo": {}, "enable": {}, "eval": {}, "exec": {}, "exit": {},
                "export": {}, "false": {}, "fc": {}, "fg": {}, "for": {},
                "function": {}, "getopts": {}, "hash": {}, "help": {}, "history": {},
                "if": {}, "jobs": {}, "kill": {}, "let": {}, "local": {},
                "logout": {}, "mapfile": {}, "popd": {}, "printf": {}, "pushd": {},
                "pwd": {}, "read": {}, "readarray": {}, "readonly": {}, "return": {},
                "set": {}, "shift": {}, "shopt": {}, "source": {}, "suspend": {},
                "test": {}, "times": {}, "trap": {}, "true": {}, "type": {},
                "typeset": {}, "ulimit": {}, "umask": {}, "unalias": {}, "unset": {},
                "until": {}, "wait": {}, "while": {}, "do": {}, "done": {},
                "elif": {}, "else": {}, "esac": {}, "fi": {}, "in": {},
                "then": {}, "case": {},
        },

        "assembly": {
                "mov": {}, "add": {}, "sub": {}, "mul": {}, "div": {}, "jmp": {},
                "cmp": {}, "je": {}, "jne": {}, "call": {}, "ret": {}, "push": {},
                "pop": {}, "nop": {}, "and": {}, "or": {}, "xor": {}, "shl": {},
                "shr": {}, "inc": {}, "dec": {}, "eax": {}, "ebx": {}, "ecx": {},
                "edx": {}, "esi": {}, "edi": {}, "esp": {}, "ebp": {}, "ax": {},
                "bx": {}, "cx": {}, "dx": {}, "data": {}, "text": {}, "byte": {},
                "word": {}, "dword": {}, "qword": {}, "ptr": {}, "proc": {},
                "segment": {}, "ends": {}, "assume": {}, "org": {}, "offset": {},
                "endp": {},
        },

        "perl": {
                "__data__": {}, "__end__": {}, "__file__": {}, "__line__": {},
                "begin": {}, "check": {}, "end": {}, "init": {}, "unitcheck": {},
                "and": {}, "cmp": {}, "continue": {}, "do": {}, "else": {},
                "elsif": {}, "eq": {}, "for": {}, "foreach": {}, "ge": {},
                "gt": {}, "if": {}, "le": {}, "lt": {}, "ne": {}, "not": {},
                "or": {}, "package": {}, "sub": {}, "unless": {}, "until": {},
                "while": {}, "xor": {}, "my": {}, "our": {}, "use": {},
        },

        "lua": {
                "and": {}, "break": {}, "do": {}, "else": {}, "elseif": {},
                "end": {}, "false": {}, "for": {}, "function": {}, "goto": {},
                "if": {}, "in": {}, "local": {}, "nil": {}, "not": {}, "or": {},
                "repeat": {}, "return": {}, "then": {}, "true": {}, "until": {},
                "while": {},
        },

        "haskell": {
                "case": {}, "class": {}, "data": {}, "default": {}, "deriving": {},
                "do": {}, "else": {}, "if": {}, "import": {}, "in": {}, "infix": {},
                "infixl": {}, "infixr": {}, "instance": {}, "let": {}, "module": {},
                "newtype": {}, "of": {}, "then": {}, "type": {}, "where": {},
                "foreign": {}, "forall": {}, "mdo": {}, "family": {}, "role": {},
                "pattern": {}, "static": {}, "group": {}, "by": {}, "using": {},
                "qualified": {},
        },

        "scala": {
                "abstract": {}, "case": {}, "catch": {}, "class": {}, "def": {},
                "do": {}, "else": {}, "extends": {}, "false": {}, "final": {},
                "finally": {}, "for": {}, "forsome": {}, "if": {}, "implicit": {},
                "import": {}, "lazy": {}, "match": {}, "new": {}, "null": {},
                "object": {}, "override": {}, "package": {}, "private": {},
                "protected": {}, "return": {}, "sealed": {}, "super": {}, "this": {},
                "throw": {}, "trait": {}, "try": {}, "true": {}, "type": {},
                "val": {}, "var": {}, "while": {}, "with": {}, "yield": {},
        },

        "objectivec": {
                "@interface": {}, "@implementation": {}, "@end": {}, "@protocol": {},
                "@class": {}, "@public": {}, "@protected": {}, "@private": {},
                "@property": {}, "@synthesize": {}, "@dynamic": {}, "@selector": {},
                "@optional": {}, "@required": {}, "@try": {}, "@catch": {},
                "@finally": {}, "@throw": {}, "@synchronized": {},
                "@autoreleasepool": {},
        },

        "dart": {
                "abstract": {}, "as": {}, "assert": {}, "async": {}, "await": {},
                "break": {}, "case": {}, "catch": {}, "class": {}, "const": {},
                "continue": {}, "covariant": {}, "default": {}, "deferred": {},
                "do": {}, "dynamic": {}, "else": {}, "enum": {}, "export": {},
                "extends": {}, "extension": {}, "external": {}, "factory": {},
                "false": {}, "final": {}, "finally": {}, "for": {}, "function": {},
                "get": {}, "hide": {}, "if": {}, "implements": {}, "import": {},
                "in": {}, "interface": {}, "is": {}, "late": {}, "library": {},
                "mixin": {}, "new": {}, "null": {}, "on": {}, "operator": {},
                "part": {}, "required": {}, "rethrow": {}, "return": {}, "set": {},
                "show": {}, "static": {}, "super": {}, "switch": {}, "sync": {},
                "this": {}, "throw": {}, "true": {}, "try": {}, "typedef": {},
                "var": {}, "void": {}, "while": {}, "with": {}, "yield": {},
        },

        "elixir": {
                "after": {}, "alias": {}, "and": {}, "case": {}, "cond": {},
                "def": {}, "defimpl": {}, "defmacro": {}, "defmodule": {},
                "defp": {}, "defprotocol": {}, "do": {}, "else": {}, "end": {},
                "fn": {}, "for": {}, "if": {}, "import": {}, "in": {}, "nil": {},
                "not": {}, "or": {}, "quote": {}, "raise": {}, "receive": {},
                "require": {}, "rescue": {}, "try": {}, "unless": {}, "unquote": {},
                "use": {}, "when": {},
        },

        "erlang": {
                "after": {}, "begin": {}, "case": {}, "catch": {}, "cond": {},
                "end": {}, "fun": {}, "if": {}, "let": {}, "of": {}, "query": {},
                "receive": {}, "try": {}, "when": {},
        },

        "r": {
                "if": {}, "else": {}, "repeat": {}, "while": {}, "function": {},
                "for": {}, "in": {}, "next": {}, "break": {}, "true": {},
                "false": {}, "null": {}, "inf": {}, "nan": {}, "na": {},
                "na_integer_": {}, "na_real_": {}, "na_complex_": {},
                "na_character_": {},
        },

        "matlab": {
                "break": {}, "case": {}, "catch": {}, "classdef": {}, "continue": {},
                "else": {}, "elseif": {}, "end": {}, "for": {}, "function": {},
                "global": {}, "if": {}, "otherwise": {}, "parfor": {}, "persistent": {},
                "return": {}, "spmd": {}, "switch": {}, "try": {}, "while": {},
        },

        "vbnet": {
                "addhandler": {}, "addressof": {}, "alias": {}, "and": {},
                "andalso": {}, "as": {}, "boolean": {}, "byref": {}, "byte": {},
                "byval": {}, "call": {}, "case": {}, "catch": {}, "cbool": {},
                "cbyte": {}, "cchar": {}, "cdate": {}, "cdec": {}, "cdbl": {},
                "char": {}, "cint": {}, "class": {}, "clng": {}, "cobj": {},
                "const": {}, "continue": {}, "csbyte": {}, "cshort": {}, "csng": {},
                "cstr": {}, "ctype": {}, "cuint": {}, "culng": {}, "cushort": {},
                "date": {}, "decimal": {}, "declare": {}, "default": {}, "delegate": {},
                "dim": {}, "directcast": {}, "do": {}, "double": {}, "each": {},
                "else": {}, "elseif": {}, "end": {}, "enum": {}, "erase": {},
                "error": {}, "event": {}, "exit": {}, "false": {}, "finally": {},
                "for": {}, "friend": {}, "function": {}, "get": {}, "gettype": {},
                "global": {}, "gosub": {}, "goto": {}, "handles": {}, "if": {},
                "implements": {}, "imports": {}, "in": {}, "inherits": {},
                "interface": {}, "is": {}, "isnot": {}, "let": {}, "lib": {},
                "like": {}, "long": {}, "loop": {}, "me": {}, "mod": {}, "module": {},
                "mustinherit": {}, "mustoverride": {}, "mybase": {}, "myclass": {},
                "namespace": {}, "narrowing": {}, "new": {}, "next": {}, "not": {},
                "nothing": {}, "notinheritable": {}, "notoverridable": {}, "object": {},
                "of": {}, "on": {}, "operator": {}, "option": {}, "optional": {},
                "or": {}, "orelse": {}, "out": {}, "overloads": {}, "overridable": {},
                "overrides": {}, "paramarray": {}, "partial": {}, "private": {},
                "protected": {}, "public": {}, "raiseevent": {}, "readonly": {},
                "redim": {}, "rem": {}, "removehandler": {}, "resume": {}, "return": {},
                "sbyte": {}, "select": {}, "set": {}, "shadows": {}, "shared": {},
                "short": {}, "single": {}, "static": {}, "step": {}, "stop": {},
                "string": {}, "structure": {}, "sub": {}, "synclock": {}, "then": {},
                "throw": {}, "to": {}, "true": {}, "try": {}, "trycast": {},
                "uinteger": {}, "ulong": {}, "ushort": {}, "using": {}, "variant": {},
                "wend": {}, "when": {}, "while": {}, "widening": {}, "with": {},
                "withevents": {}, "writeonly": {}, "xor": {}, "integer": {},
                "typeof": {},
        },

        "cobol": {
                "accept": {}, "add": {}, "call": {}, "cancel": {}, "close": {},
                "compute": {}, "configuration": {}, "copy": {}, "data": {},
                "delete": {}, "display": {}, "divide": {}, "else": {}, "end-if": {},
                "exit": {}, "fd": {}, "file": {}, "if": {}, "initialize": {},
                "inspect": {}, "move": {}, "multiply": {}, "open": {}, "perform": {},
                "read": {}, "rewrite": {}, "search": {}, "stop": {}, "subtract": {},
                "write": {}, "program-id": {}, "author": {}, "date-written": {},
                "environment": {}, "division": {}, "section": {}, "working-storage": {},
        },

        "fortran": {
                "allocate": {}, "assign": {}, "backspace": {}, "block": {},
                "data": {}, "call": {}, "close": {}, "common": {}, "continue": {},
                "deallocate": {}, "do": {}, "else": {}, "else if": {},
                "end": {}, "end file": {}, "endfile": {}, "endif": {}, "entry": {},
                "equivalence": {}, "external": {}, "format": {}, "function": {},
                "go to": {}, "goto": {}, "if": {}, "implicit": {}, "inquire": {},
                "integer": {}, "intrinsic": {}, "logical": {}, "open": {},
                "parameter": {}, "pause": {}, "print": {}, "program": {}, "read": {},
                "return": {}, "rewind": {}, "stop": {}, "subroutine": {}, "then": {},
                "type": {}, "write": {},
        },

        "julia": {
                "begin": {}, "while": {}, "for": {}, "return": {}, "break": {},
                "continue": {}, "function": {}, "macro": {}, "quote": {}, "try": {},
                "catch": {}, "finally": {}, "let": {}, "if": {}, "else": {},
                "elseif": {}, "struct": {}, "module": {}, "baremodule": {}, "using": {},
                "import": {}, "export": {}, "const": {}, "global": {}, "local": {},
                "mutable": {}, "abstract": {}, "primitive": {}, "type": {},
                "immutable": {}, "typealias": {}, "bitstype": {}, "do": {}, "end": {},
                "where": {},
        },

        "prolog": {
                ":-": {}, "--": {}, "?-": {}, "is": {}, "assert": {}, "retract": {},
                "clause": {}, "true": {}, "fail": {}, "not": {}, "repeat": {},
                "call": {}, "if": {}, "then": {}, "else": {},
        },

        "eiffel": {
                "across": {}, "agent": {}, "alias": {}, "all": {}, "and": {},
                "as": {}, "assign": {}, "check": {}, "class": {}, "convert": {},
                "create": {}, "debug": {}, "deferred": {}, "do": {}, "else": {},
                "elseif": {}, "end": {}, "ensure": {}, "expanded": {}, "export": {},
                "external": {}, "feature": {}, "from": {}, "frozen": {}, "if": {},
                "implies": {}, "inherit": {}, "inspect": {}, "invariant": {},
                "like": {}, "local": {}, "loop": {}, "not": {}, "note": {},
                "obsolete": {}, "old": {}, "once": {}, "or": {}, "prefix": {},
                "redefine": {}, "rename": {}, "require": {}, "rescue": {}, "retry": {},
                "select": {}, "separate": {}, "then": {}, "undefine": {}, "until": {},
                "variant": {}, "when": {},
        },
}

// languageAliases maps different variations of language
// names to their canonical form.
var languageAliases = map[string]string{
        "js":     "javascript",
        "jsx":    "javascript",
        "ts":     "typescript",
        "py":     "python",
        "rb":     "ruby",
        "golang": "go",
        "c++":    "cpp",
        "cxx":    "cpp",
        "h":      "cpp",
        "hpp":    "cpp",
}

// languageConfig holds language-specific validation rules.
type languageConfig struct {
        language      string          // the language name
        caseSensitive bool            // is the language case-sensitive
        allowUnicode  bool            // allow unicode characters in identifiers
        checkFirst    func(rune) bool // check the first character
        validChars    func(rune) bool // check if a character is valid
}

var languageConfigs = map[string]languageConfig{
        "python": {
                language:      "python",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "javascript": {
                language:      "javascript",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '$'
                }</span>,
        },
        "typescript": {
                language:      "typescript",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '$'
                }</span>,
        },
        "php": {
                language:      "php",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "ruby": {
                language:      "ruby",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov0" title="0">{
                        return unicode.IsLetter(r) || r == '_' || r == '@' || r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov0" title="0">{
                        // For Ruby variables and methods, we need to check
                        // the position of the character ? and ! can only be at the end
                        // @@ for class variables
                        // @ for instance variables
                        // $ for global variables
                        return false // replace the logic in the VariableNameFor function
                }</span>,
        },
        "perl": {
                language:      "perl",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "lua": {
                language:      "lua",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "go": {
                language:      "go",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "rust": {
                language:      "rust",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "cpp": {
                language:      "cpp",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "c": {
                language:      "c",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "java": {
                language:      "java",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '$'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '$'
                }</span>,
        },
        "kotlin": {
                language:      "kotlin",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "swift": {
                language:      "swift",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "sql": {
                language:      "sql",
                caseSensitive: false,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '@' || r == '#'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' ||
                                r == '@' || r == '#' || r == '$'
                }</span>,
        },
        "html": {
                language:      "html",
                caseSensitive: false,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '-'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '-'
                }</span>,
        },
        "css": {
                language:      "css",
                caseSensitive: false,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_' || r == '-' || r == '@'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '-' || r == '@'
                }</span>,
        },
        "r": {
                language:      "r",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '.' || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '.' || r == '_'
                }</span>,
        },
        "matlab": {
                language:      "matlab",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r)
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
        "haskell": {
                language:      "haskell",
                caseSensitive: true,
                allowUnicode:  false,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLower(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) ||
                                unicode.IsNumber(r) || r == '_' || r == '\''
                }</span>,
        },
        "scala": {
                language:      "scala",
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        },
}

// isLanguageSupported checks if the language is supported.
func isLanguageSupported(language string) bool <span class="cov8" title="1">{
        language = strings.ToLower(language)
        if alias, ok := languageAliases[language]; ok </span><span class="cov0" title="0">{
                language = alias
        }</span>

        <span class="cov8" title="1">_, exists := reservedWords[language]
        return exists</span>
}

// isReservedInAnyLanguage checks if the given word is reserved
// in any programming language.
func isReservedInAnyLanguage(word string) bool <span class="cov8" title="1">{
        for _, langWords := range reservedWords </span><span class="cov8" title="1">{
                if _, reserved := langWords[word]; reserved </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isValidIdentifier checks if the variable name conforms to the basic rules:
// starts with a valid character and contains only valid characters.
func isValidIdentifier(v string, config languageConfig) bool <span class="cov8" title="1">{
        r := []rune(v)

        // Check if empty
        if len(r) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // If Unicode is not allowed, check all characters
        <span class="cov8" title="1">if !config.allowUnicode </span><span class="cov8" title="1">{
                for _, c := range r </span><span class="cov8" title="1">{
                        if c &gt; unicode.MaxASCII </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        // Check if the name starts with a valid character
        <span class="cov8" title="1">if !config.checkFirst(r[0]) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Handle Ruby's special case
        <span class="cov8" title="1">if config.language == "ruby" </span><span class="cov8" title="1">{
                // Remove prefixes @, @@, $
                if strings.HasPrefix(v, "@@") </span><span class="cov8" title="1">{
                        r = r[2:]
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(v, "@") || strings.HasPrefix(v, "$") </span><span class="cov8" title="1">{
                        r = r[1:]
                }</span>

                <span class="cov8" title="1">if len(r) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Check first character after prefix
                <span class="cov8" title="1">if !unicode.IsLetter(r[0]) &amp;&amp; r[0] != '_' </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Check remaining characters
                <span class="cov8" title="1">for i, c := range r </span><span class="cov8" title="1">{
                        if !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) &amp;&amp; c != '_' </span><span class="cov0" title="0">{
                                // Allow ? and ! only at the end
                                if (c != '?' &amp;&amp; c != '!') || i != len(r)-1 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }

                <span class="cov8" title="1">return true</span>
        }

        // Check all characters explicitly
        <span class="cov8" title="1">for _, c := range r </span><span class="cov8" title="1">{
                if !config.validChars(c) </span><span class="cov8" title="1">{
                        return false
                }</span>

                // Additional checks for special characters that should never be allowed
                // unless explicitly permitted by checkFirst/validChars
                <span class="cov8" title="1">if c == ' ' || c == '#' || c == '-' </span><span class="cov0" title="0">{
                        // These characters are always invalid unless explicitly allowed
                        if !config.validChars(c) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                // Special handling for @ - allowed if it's permitted by checkFirst
                <span class="cov8" title="1">if c == '@' &amp;&amp; !config.checkFirst('@') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// VariableNameFor validates if the given string can be used as a
// variable name in the specified programming language.
//
// Parameters:
//   - v: string to validate;
//   - language: programming language to check against (case-insensitive);
//
// Returns:
//   - bool: true if the given name is valid for the specified language;
//   - error: ErrLanguageNotSupported if the language is not supported.
func VariableNameFor(v string, language string) (bool, error) <span class="cov8" title="1">{
        // Empty string is not a valid variable name regardless of language
        if v == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Save original language name for error messages
        <span class="cov8" title="1">originalLanguage := language

        // Normalize language name
        language = strings.TrimSpace(language)

        // Empty language name is not valid
        if language == "" </span><span class="cov8" title="1">{
                return false, ErrLanguageNotSupported(originalLanguage)
        }</span>

        // Convert to lowercase for case-insensitive comparison
        <span class="cov8" title="1">language = strings.ToLower(language)
        if alias, ok := languageAliases[language]; ok </span><span class="cov8" title="1">{
                language = alias
        }</span>

        // Check if language is supported
        <span class="cov8" title="1">if !isLanguageSupported(language) </span><span class="cov8" title="1">{
                return false, ErrLanguageNotSupported(originalLanguage)
        }</span>

        // Get language config
        <span class="cov8" title="1">config, hasConfig := languageConfigs[language]
        if !hasConfig </span><span class="cov0" title="0">{
                config = languageConfig{
                        caseSensitive: true,
                        allowUnicode:  false,
                        checkFirst: func(r rune) bool </span><span class="cov0" title="0">{
                                return unicode.IsLetter(r) || r == '_'
                        }</span>,
                        validChars: func(r rune) bool <span class="cov0" title="0">{
                                return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                        }</span>,
                }
        }

        // Convert to runes
        <span class="cov8" title="1">runes := []rune(v)
        if len(runes) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if langWords, exists := reservedWords[language]; exists </span><span class="cov8" title="1">{
                checkWord := v

                // Remove prefixes and suffixes for checking reserved words
                switch language </span>{
                case "php":<span class="cov8" title="1">
                        if strings.HasPrefix(checkWord, "$") </span><span class="cov8" title="1">{
                                checkWord = checkWord[1:]
                        }</span>
                case "ruby":<span class="cov8" title="1">
                        if strings.HasPrefix(checkWord, "@@") </span><span class="cov8" title="1">{
                                checkWord = checkWord[2:]
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(checkWord, "@") </span><span class="cov8" title="1">{
                                checkWord = checkWord[1:]
                        }</span> else<span class="cov8" title="1"> if strings.HasPrefix(checkWord, "$") </span><span class="cov8" title="1">{
                                checkWord = checkWord[1:]
                        }</span>
                        <span class="cov8" title="1">if strings.HasSuffix(checkWord, "?") </span><span class="cov8" title="1">{
                                checkWord = checkWord[:len(checkWord)-1]
                        }</span> else<span class="cov8" title="1"> if strings.HasSuffix(checkWord, "!") </span><span class="cov8" title="1">{
                                checkWord = checkWord[:len(checkWord)-1]
                        }</span>
                }

                // Check for reserved words considering case sensitivity
                <span class="cov8" title="1">if config.caseSensitive </span><span class="cov8" title="1">{
                        if _, isReserved := langWords[checkWord]; isReserved </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                } else<span class="cov8" title="1"> {
                        checkWord = strings.ToLower(checkWord)
                        for reserved := range langWords </span><span class="cov8" title="1">{
                                if strings.ToLower(reserved) == checkWord </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>
                        }
                }
        }

        // Special cases for Ruby
        <span class="cov8" title="1">if language == "ruby" </span><span class="cov8" title="1">{
                // Check for class variables (@@)
                if strings.HasPrefix(v, "@@") </span><span class="cov8" title="1">{
                        runes = runes[2:] // skip @@ for further checks
                        if len(runes) == 0 </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                        <span class="cov8" title="1">if !unicode.IsLetter(runes[0]) &amp;&amp; runes[0] != '_' </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(v, "@") </span><span class="cov8" title="1">{ // instance variables
                        runes = runes[1:] // skip @ for further checks
                        if len(runes) == 0 </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                        <span class="cov8" title="1">if !unicode.IsLetter(runes[0]) &amp;&amp; runes[0] != '_' </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasPrefix(v, "$") </span><span class="cov8" title="1">{ // global variables
                        runes = runes[1:] // skip $ for further checks
                        if len(runes) == 0 </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                        <span class="cov8" title="1">if !unicode.IsLetter(runes[0]) &amp;&amp; runes[0] != '_' </span><span class="cov8" title="1">{
                                return false, nil
                        }</span>
                }

                // If single ?, ! or only prefix without variable name
                <span class="cov8" title="1">if len(runes) == 1 &amp;&amp; (runes[0] == '?' || runes[0] == '!' ||
                        runes[0] == '@' || runes[0] == '$') </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">if len(runes) == 2 &amp;&amp; runes[0] == '@' &amp;&amp; runes[1] == '@' </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                // Check ending character ? or !
                <span class="cov8" title="1">runeCount := len(runes)
                for i, r := range runes </span><span class="cov8" title="1">{
                        if r == '?' || r == '!' </span><span class="cov8" title="1">{
                                // If ? or ! is the first character or not at the end
                                if i == 0 || i != runeCount-1 </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>
                                // Check if there is at least one valid character before ? or !
                                <span class="cov8" title="1">prev := runes[i-1]
                                if !unicode.IsLetter(prev) &amp;&amp;
                                        !unicode.IsNumber(prev) &amp;&amp; prev != '_' </span><span class="cov0" title="0">{
                                        return false, nil
                                }</span>
                        }
                        <span class="cov8" title="1">if !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) &amp;&amp; r != '_' &amp;&amp;
                                !(i == runeCount-1 &amp;&amp; (r == '?' || r == '!')) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                }

                <span class="cov8" title="1">return true, nil</span>
        }

        // Check first character
        <span class="cov8" title="1">if !config.checkFirst(runes[0]) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // Special case for PHP: if starts with $, check the next character
        <span class="cov8" title="1">if language == "php" &amp;&amp; runes[0] == '$' </span><span class="cov8" title="1">{
                if len(runes) &lt; 2 </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">runes = runes[1:] // skip $ for further checks
                if !unicode.IsLetter(runes[0]) &amp;&amp; runes[0] != '_' </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        // Check remaining characters
        <span class="cov8" title="1">for _, r := range runes </span><span class="cov8" title="1">{
                // For non-Unicode languages, check if character is ASCII
                if !config.allowUnicode &amp;&amp; r &gt; unicode.MaxASCII </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if !config.validChars(r) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// VarFor is synonym for VariableNameFor function.
func VarFor(v string, language string) (bool, error) <span class="cov8" title="1">{
        return VariableNameFor(v, language)
}</span>

// VariableName validates if the given string can be used as a
// variable name without considering specific programming language.
//
// Parameters:
//   - v: string to validate
//   - strict: if true, checks if the word is reserved in
//     any programming language.
//
// Returns true if the given name is valid.
func VariableName(v string, strict ...bool) bool <span class="cov8" title="1">{
        // Empty string is not a valid variable name.
        if v == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Default configuration
        <span class="cov8" title="1">config := languageConfig{
                caseSensitive: true,
                allowUnicode:  true,
                checkFirst: func(r rune) bool </span><span class="cov8" title="1">{
                        return unicode.IsLetter(r) || r == '_'
                }</span>,
                validChars: func(r rune) bool <span class="cov8" title="1">{
                        return unicode.IsLetter(r) || unicode.IsNumber(r) || r == '_'
                }</span>,
        }

        // Convert to runes for proper Unicode handling
        <span class="cov8" title="1">runes := []rune(v)

        // Check first character
        if !config.checkFirst(runes[0]) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check all characters explicitly
        <span class="cov8" title="1">for _, r := range runes </span><span class="cov8" title="1">{
                if !config.validChars(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Check if word is reserved in any language when strict mode is enabled
        <span class="cov8" title="1">if g.All(strict...) &amp;&amp; isReservedInAnyLanguage(v) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Var is synonym for VariableName function.
func Var(v string, strict ...bool) bool <span class="cov8" title="1">{
        return VariableName(v, strict...)
}</span>

// SelectorName checks if the given string is a valid CSS/HTML selector name.
// It supports simple selectors including elements (e.g., "div"), classes
// (e.g., ".myClass"), and IDs (e.g., "#myID").
//
// Parameters:
//   - v: string to validate;
//   - strict: if true, the leading characters # and . are inadmissible.
//
// Returns true if the given name is a valid selector.
func SelectorName(v string, strict ...bool) bool <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Determine if strict mode is enabled.
        <span class="cov8" title="1">isStrict := g.All(strict...)

        // Select the appropriate regex based on the mode.
        rgex := g.If(isStrict, selectorStrictRegex, selectorRegex)
        isValidSelector := rgex.MatchString(v)

        // If valid selector, also check if it's not a reserved word in CSS.
        if isValidSelector </span><span class="cov8" title="1">{
                // Remove leading # or . for checking.
                checkWord := v
                if len(checkWord) &gt; 0 &amp;&amp; (checkWord[0] == '#' || checkWord[0] == '.') </span><span class="cov8" title="1">{
                        checkWord = checkWord[1:]
                }</span>

                // Check in CSS reserved words if strict mode is enabled.
                <span class="cov8" title="1">if isStrict </span><span class="cov8" title="1">{
                        if cssWords, exists := reservedWords["css"]; exists </span><span class="cov8" title="1">{
                                if _, reserved := cssWords[checkWord]; reserved </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return isValidSelector</span>
}

// Sel is synonym for SelectorName function.
func Sel(v string, strict ...bool) bool <span class="cov0" title="0">{
        return SelectorName(v, strict...)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package is

import (
        "regexp"
        "strings"
)

var (
        // Regular expression pattern for a valid email slug (local/domain part).
        slugPattern = `[\p{L}\p{N}]{1,}([\p{L}\p{N}.-]{1,}[\p{L}\p{N}]{1,})?`

        // Compiled regex for the local part of the email.
        localRegex = regexp.MustCompile(`^` + slugPattern + `$`)

        // Compiled regex for the domain part of the email.
        domainRegex = regexp.MustCompile(`^` + slugPattern + `\.[\p{L}\p{N}]{2,}$`)
)

// Email validates an email address and returns a boolean result.
// The function checks for email length, splits the email into local and
// domain parts, validates the length of the local part, and finally uses
// regular expressions to check the format of each part.
//
// Example usage:
//
//        is.Email("test@example.com")  // Output: true
//        is.Email("TEST@EXAMPLE.COM")  // Output: true
//        is.Email(" test@example.com") // Output: false
//        is.Email("test@example.c")    // Output: false
//
// The function performs only a format check, so it does not clean spaces
// at the beginning and end of a line, does not remove tab characters and
// carriage returns to a new line. You can use the g.Wedd and g.Trim
// functions for it:
//
//        is.Email(g.Trim(" test@example.com\n"))   // Output: true
//        is.Email(g.Weed("test\t@example.com\n"))  // Output: true
func Email(email string) bool <span class="cov8" title="1">{
        // Check the overall length.
        if len(email) &gt; 254 || len(email) &lt; 6 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Split the email into local and domain parts.
        <span class="cov8" title="1">parts := strings.Split(email, "@")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">local, domain := parts[0], parts[1]

        // Check the length of the local part.
        if len(local) &gt; 64 || len(local) &lt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if both parts are valid.
        <span class="cov8" title="1">if !localRegex.MatchString(local) || !domainRegex.MatchString(domain) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package is

import (
        "fmt"
        "strconv"
)

// Latitude validates if the given value is a valid geographic latitude.
// A latitude represents a geographic coordinate that specifies the north-south
// position of a point on the Earth's surface. It is an angle which ranges from
// -90 to +90 degrees.
//
// The function takes a float64 number representing the latitude and checks if
// it falls within the valid range.
//
// Example usage:
//
//        is.Latitude(-45.0) // Returns: true
//        is.Latitude(90.1)  // Returns: false
func Latitude[T string | float64](lat T) bool <span class="cov8" title="1">{
        v, err := strconv.ParseFloat(fmt.Sprint(lat), 64)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return v &gt;= -90 &amp;&amp; v &lt;= 90</span>
}

// Longitude validates if the given value is a valid geographic longitude.
// A longitude represents a geographic coordinate that specifies the east-west
// position of a point on the Earth's surface. It is an angle which ranges
// from -180 to +180 degrees.
//
// The function takes a float64 number representing the longitude and checks
// if it falls within the valid range.
//
// Example usage:
//
//        is.Longitude(-45.0) // Returns: true
//        is.Longitude(180.1) // Returns: false
func Longitude[T string | float64](lon T) bool <span class="cov8" title="1">{
        v, err := strconv.ParseFloat(fmt.Sprint(lon), 64)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return v &gt;= -180 &amp;&amp; v &lt;= 180</span>
}

// Coordinates validates if the given pair of values represent valid
// geographic coordinates. The pair consists of a latitude and a longitude.
//
// The function takes two float64 numbers representing the latitude and the
// longitude and checks if they fall within the valid ranges for their
// respective geographic coordinate systems.
//
// Example usage:
//
//        is.Coordinates(45.0, -123.1) // Returns: true
//        is.Coordinates(90.1, 180.1)  // Returns: false
func Coordinates[T string | float64](lat, lon T) bool <span class="cov8" title="1">{
        return Latitude(lat) &amp;&amp; Longitude(lon)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package is

import (
        "regexp"
        "strings"
)

var (
        // The base64Regex is a regex pattern used to validate
        // standard Base64 encoded strings.
        // It matches strings that:
        //  - consist of sequences of 4 valid Base64 characters (A-Za-z0-9+/),
        //    repeated 0 or more times.
        //  - optionally, end with a sequence of 2 valid Base64 characters
        //    followed by '==', or 3 valid Base64 characters followed by '=',
        //    or 4 valid Base64 characters.
        base64Regex = regexp.MustCompile(
                `^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|` +
                        `[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{4})$`,
        )

        // The base64URLRegex is a regex pattern used to validate
        // URL-safe Base64 encoded strings.
        // It matches strings that:
        //  - consist of sequences of 4 valid URL-safe Base64 characters
        //    (A-Za-z0-9_-), repeated 0 or more times.
        //  - optionally, end with a sequence of 2 valid URL-safe Base64 characters
        //    followed by '==', or 3 valid URL-safe Base64 characters followed by
        //    '=', or 4 valid URL-safe Base64 characters.
        //
        // Note: all base64URL strings:
        //  `^(?:[A-Za-z0-9_-]{4})*((?:[A-Za-z0-9_-]{2,4})|` +
        //  `(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=|` +
        //  `[A-Za-z0-9+\\/]{4}))$`
        base64URLRegex = regexp.MustCompile(
                `^([A-Za-z0-9_-]{4})*([A-Za-z0-9_-]{2}(==)?|[A-Za-z0-9_-]{3}=?)?$`,
        )

        // The hexRegex is a regex pattern used to validate hexadecimal strings.
        hexRegex = regexp.MustCompile(`^(#|0x)?[0-9a-fA-F]+$`)

        // The binRegex is a regex pattern used to validate binary strings.
        binRegex = regexp.MustCompile(`^(0b)?[01]+$`)

        // The hexColorRegex is a regex pattern used to validate
        // hexadecimal color strings.
        hexColorRegex = regexp.MustCompile(`^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$`)

        // The rgbRegex is a regex pattern used to validate RGB color strings.
        rgbColorRegex = regexp.MustCompile(
                `^(rgb|RGB)\(\s*([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,` +
                        `\s*([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,` +
                        `\s*([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*\)$`,
        )
)

// Base64 validates whether a given string 'v' is a valid Base64
// encoded string.
//
// Base64 is a binary-to-text encoding scheme that is commonly used
// to encode binary data, notably when that data needs to be stored and
// transferred over media designed to handle text. This encoding helps to
// ensure that the data remains intact without modification during transport.
//
// This function uses a regular expression to verify that the input string
// conforms to the format of a Base64 encoded string. It checks if the string
// can be evenly divided by 4, and only contains valid Base64 characters
// (A-Z, a-z, 0-9, +, /, and = for padding). The padding at the end of
// Base64 string, which is one or two '=' characters, is also checked for.
//
// If the input string matches this format, the function returns true,
// indicating that the string is a valid Base64 encoded string.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.Base64("SGVsbG8sIHdvcmxkIQ==") // Returns: true
//        is.Base64("SGVsbG8sIHdvcmxkIQ")   // Returns: false
//
// Note: This function does not validate the content of the encoded data,
// just the format of Base64 strings.
func Base64(v string) bool <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return base64Regex.MatchString(v)</span>
}

// Base64URL validates whether a given string 'v' is a valid URL-safe Base64
// encoded string.
//
// URL-safe Base64 encoding is similar to standard Base64 encoding, but it uses
// different characters to represent the encoded data, making it safe to use in
// URLs and filenames. The characters '+' and '/' in standard Base64 encoding
// are replaced with '-' and '_' respectively in URL-safe Base64 encoding.
// The padding character '=' is also used in URL-safe Base64 encoding.
//
// This function uses a regular expression to verify that the input string
// conforms to the format of a URL-safe Base64 encoded string. It checks if
// the string can be evenly divided by 4, and only contains valid URL-safe
// Base64 characters (A-Z, a-z, 0-9, -, and _ for padding). The padding at
// the end of URL-safe Base64 string, which is one or two '=' characters,
// is also checked for.
//
// If the input string matches this format, the function returns true,
// indicating that the string is a valid URL-safe Base64 encoded string.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.Base64URL("SGVsbG8sIHdvcmxkIQ")    // Returns: true
//        is.Base64URL("SGVsbG8sIHdvcmxkIQ==")  // Returns: true
//        is.Base64URL("SGVsbG8sIHdvcmxkIQ===") // Returns: false
//
// Note: This function does not validate the content of the encoded data,
// just the format of URL-safe Base64 strings.
func Base64URL(v string) bool <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return base64URLRegex.MatchString(v)</span>
}

// Hex validates whether a given string 'v' is a valid hexadecimal value.
//
// A hexadecimal value is a number that includes digits from 0 to 9 and
// letters from A to F (either lower case or upper case). Hexadecimal values
// are often used in computing to represent numbers in a human-readable format.
//
// This function does not require '0x' or '#' prefix to be present in the
// input string, although it will accept strings with these prefixes.
//
// The function uses a regular expression to verify that the input string
// conforms to the format of a hexadecimal number.
//
// If the input string matches this format, the function returns true,
// indicating that the string is a valid hexadecimal value.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.Hex("deadBEEF") // Returns: true
//        is.Hex("#c0ffee")  // Returns: true
//        is.Hex("nothex")   // Returns: false
//
// Note: This function does not validate semantic correctness,
// just the format of hexadecimal values.
func Hex(v string) bool <span class="cov8" title="1">{
        return hexRegex.MatchString(v)
}</span>

// Bin validates whether a given string 'v' is a valid binary value.
//
// A binary value is a number that includes only the digits 0 and 1.
// Binary values are the most basic unit of data in computing and digital
// communications.
//
// This function does not require '0b' prefix to be present in the
// input string, although it will accept strings with this prefix.
//
// The function uses a regular expression to verify that the input string
// conforms to the format of a binary number.
//
// If the input string matches this format, the function returns true,
// indicating that the string is a valid binary value.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.Bin("101010") // Returns: true
//        is.Bin("0b1101")  // Returns: true
//        is.Bin("10201")   // Returns: false
//
// Note: This function does not validate semantic correctness,
// just the format of binary values.
func Bin(v string) bool <span class="cov8" title="1">{
        return binRegex.MatchString(v)
}</span>

// HexColor validates whether a given string 'v' is a valid hexadecimal
// RGB color value. Hexadecimal RGB color values are defined as '#&lt;color&gt;',
// where &lt;color&gt; is either a  3-digit or a 6-digit hexadecimal number.
// Each digit is in the range 0-9 and A-F (either lower case or upper case).
//
// The function uses a regular expression to verify that the input string
// conforms to this format.
//
// In the case of a 3-digit color, each digit represents a color value for red,
// green, and blue respectively. Each digit is equivalent to repeating it twice
// in a 6-digit color. For example, "#123" in 3-digit color is equivalent to
// "#112233" in 6-digit color.
//
// In the case of a 6-digit color, the first two digits represent red, the next
// two represent green, and the last two represent blue.
//
// If the input string matches this format, the function returns true,
// indicating that the string is a valid hexadecimal RGB color value.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.HexColor("#fff")    // Returns: true
//        is.HexColor("#efef01") // Returns: true
//        is.HexColor("not")     // Returns: false
//
// Note: The function does not validate color semantic correctness,
// just the format of hexadecimal RGB colors.
func HexColor(v string) bool <span class="cov8" title="1">{
        return hexColorRegex.MatchString(v)
}</span>

// RGBColor validates whether a given string 'v' is a valid RGB color value.
// RGB color values are defined as 'rgb(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;)', where each
// of &lt;red&gt;, &lt;green&gt;, and &lt;blue&gt; is an integer in the range 0-255.
// The function uses a regular expression to verify that the input
// string conforms to this format.
//
// The function does not account for leading or trailing spaces in the input
// string. The values for red, green, and blue must be separated by commas.
// These can be followed by spaces, tabs, or newline characters, all of which
// are considered valid. The entire string must be enclosed within 'rgb()'
// with no spaces between 'rgb' and the opening parenthesis.
//
// If the input string matches this format and all color values are in the
// range 0-255, the function returns true, indicating that the string is a
// valid RGB color value. Otherwise, it returns false.
//
// Example usage:
//
//        is.RGBColor("rgb(255, 255, 255)") // Returns: true
//        is.RGBColor("rgb(255, 255, 256)") // Returns: false
//        is.RGBColor("rgb(255, 255)")      // Returns: false
//
// Note: The function doesn't validate color semantic correctness,
// just the syntax and range of values.
func RGBColor(v string) bool <span class="cov8" title="1">{
        return rgbColorRegex.MatchString(v)
}</span>

// JWT checks if the given string is a valid JSON Web Token (JWT).
// JWTs are used for securely transmitting information between parties
// as a JSON object. They consist of three parts: header, payload,
// and signature, separated by dots.
//
// This function validates the JWT by performing the following checks:
// 1. The input string should consist of three parts separated by dots.
// 2. Each part should be a valid Base64URL encoded string.
//
// If the input string passes these checks, the function returns true,
// indicating that the string is a valid JWT. Otherwise, it returns false.
//
// Example usage:
//
//        is.JWT("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIi" +
//               "wibWVzc2FnZSI6IkhlbGxvIFdvcmxkIiwiaWF0IjoxNTE2MjM5MDIyfQ.pfdTXv" +
//               "HNIobiLJJ1MoiNyuzf5ZaUCpMu889Q8AJaWjs") // Returns: true
//        is.JWT("notajwt") // Returns: false
func JWT(v string) bool <span class="cov8" title="1">{
        parts := strings.Split(v, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                if !Base64URL(part) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// MD5 checks if the given string is a valid MD5 hash.
// MD5 is a widely used cryptographic hash function that produces
// a 128-bit (16-byte) hash value. It is commonly used to verify
// data integrity and to store passwords.
//
// This function validates the MD5 hash by performing the following checks:
// 1. The input string should consist of exactly 32 characters.
// 2. Each character should be a valid hexadecimal digit (0-9, a-f, A-F).
//
// If the input string passes these checks, the function returns true,
// indicating that the string is a valid MD5 hash. Otherwise, it returns false.
//
// Example usage:
//
//        is.MD5("d41d8cd98f00b204e9800998ecf8427e") // Returns: true
//        is.MD5("notamd5hash") // Returns: false
func MD5(v string) bool <span class="cov8" title="1">{
        return len(v) == 32 &amp;&amp; Hex(v)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package is includes validation functions of various data such as e-mail,
// bank card number, bank account IBAN, phone number and others.
//
// The package provides validation functions that do not pre-clean the data.
// If the validation data needs to be cleaned, it must be cleaned beforehand,
// for example using the g package.
//
// Example:
//
//        data := "UA 90 305299 2990004149123456789" // contains spaces
//        iban := g.Weed(data, g.Whitespaces)        // remove spaces
//        is.Iban(iban) // Output: true
//        is.Iban(data) // Output: false
package is

import "github.com/goloop/g"

// Numerable is an interface type that is satisfied by all numeric types
// in Go, both integer and floating point. This includes int, int8, int16,
// int32, int64, uint, uint8, uint16, uint32, uint64, float32, and float64.
// It allows functions to operate on any of these types where numerical
// operations such as addition, subtraction, multiplication, and division
// are needed. It enables generic programming techniques for numeric types.
type Numerable interface {
        g.Numerable
}

// Verifiable is an interface type that is satisfied by classical types
// like numeric types and strings in Go.
//
// The purpose of the Verifiable interface is to enable generic programming
// techniques for numeric types and strings. Functions can use this interface
// as a constraint to operate on any of these types where numerical operations
// or string operations are needed.
type Verifiable interface {
        g.Verifiable
}

// The init initializes this package.
func init() <span class="cov8" title="1">{
        // Initialize the letterToNumberCache map.
        // See IBAN validation for more details.
        for _, letter := range "ABCDEFGHIJKLMNOPQRSTUVWXYZ" </span><span class="cov8" title="1">{
                letterToNumberCache[letter] = int(letter-'A') + 10
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package is

import (
        "net"
        "strconv"
        "strings"
)

// IPv4 checks if the string is a valid representation of an IPv4 address.
// An IPv4 address consists of four numbers separated by dots.
// Each number should be within the range of 0 to 255.
// Leading zeros are allowed. Empty strings or strings with more than
// four parts are not considered as valid IPv4 addresses.
//
// Example usage:
//
//        is.IPv4("127.0.0.1")       // Returns: true
//        is.IPv4("192.168.0.1")     // Returns: true
//        is.IPv4("0.0.0.0")         // Returns: true
//        is.IPv4("255.255.255.255") // Returns: true
//
//        is.IPv4("256.0.0.1")     // Returns: false, numbers exceed the range
//        is.IPv4("192.168.0")     // Returns: false, only three parts
//        is.IPv4("192.168.0.1.1") // Returns: false, more than four parts
//        is.IPv4("192.168.0.one") // Returns: false, non-numeric characters
//        is.IPv4("")              // Returns: false, empty string
//
// This function can be used to validate user input to ensure
// an IPv4 address entered is in the correct format before
// attempting to use it in network operations.
func IPv4(ip string) bool <span class="cov8" title="1">{
        parts := strings.Split(ip, ".")
        if len(parts) != 4 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                if len(part) == 0 || (len(part) &gt; 1 &amp;&amp; part[0] == '0') </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">num, err := strconv.Atoi(part)
                if err != nil || num &lt; 0 || num &gt; 255 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IPv6 checks if the string is a valid representation of an IPv6 address.
// An IPv6 address consists of eight groups of four hexadecimal digits,
// each group representing 16 bits. The groups are separated by colons (:).
//
// This function uses the net.ParseIP function from the Go standard library
// which returns a valid IP address (either IPv6 or IPv4). The function then
// checks if the string contains a colon, which is a requirement for it to be
// an IPv6 address.
//
// Example usage:
//
//        is.IPv6("2001:0db8:85a3:0000:0000:8a2e:0370:7334") // Returns: true
//        is.IPv6("2001:db8:85a3:0:0:8a2e:370:7334")         // Returns: true
//        is.IPv6("2001:db8:85a3::8a2e:370:7334")            // Returns: true
//        is.IPv6("::1")                                     // Returns: true
//        is.IPv6("::")                                      // Returns: true
//
//        // The group "37023" exceeds 16 bits.
//        is.IPv6("2001:db8::8a2e:37023:7334") // Returns: false
//
//        // Only one "::" is allowed in an IPv6 address.
//        is.IPv6("2001::25de::cade") // Returns: false
//
//        // This is an IPv4 address.
//        is.IPv6("192.168.0.1") // Returns: false,
//        is.IPv6("") // Returns: false, empty string
//
// This function can be used to validate user input to ensure an IPv6
// address entered is in the correct format before attempting to use
// it in network operations.
func IPv6(ip string) bool <span class="cov8" title="1">{
        return net.ParseIP(ip) != nil &amp;&amp; strings.Contains(ip, ":")
}</span>

// IP checks if the string is a valid representation of an IP address.
// The IP address can be either IPv4 or IPv6.
//
// This function first checks if the string is a valid IPv4 address using
// the IPv4 function, if that check fails it then checks if the string is
// a valid IPv6 address using the IPv6 function.
//
// Example usage:
//
//        is.IP("127.0.0.1")       // Returns: true, valid IPv4
//        is.IP("::1")             // Returns: true, valid IPv6
//        is.IP("2001:db8::8a2e")  // Returns: true, valid IPv6
//
//        is.IP("256.0.0.1")     // Returns: false, invalid IPv4
//        is.IP("192.168.0")     // Returns: false, invalid IPv4
//        is.IP("2001::25de::cade") // Returns: false, invalid IPv6
//        is.IP("")              // Returns: false, empty string
//
// This function can be used to validate user input to ensure
// an IP address entered is in the correct format before
// attempting to use it in network operations.
func IP(ip string) bool <span class="cov8" title="1">{
        return IPv4(ip) || IPv6(ip)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package is

import (
        "github.com/goloop/g"
)

// Even checks if a value is an even number.
//
// The function accepts a value of any type T that satisfies
// the Numerable interface. If the `f` argument is provided
// and set to true, the function ignores the fractional part
// of the value when checking for evenness. For integer types,
// it checks if the value is divisible by 2 without a remainder.
// For floating-point types, it considers only the integer part
// of the value and determines the parity of the integer part.
// If the value has a non-zero fractional part and `f` is true,
// it returns false since an even number cannot have a fractional part.
//
// Example usage:
//
//        even := is.Even(6)
//        fmt.Println(even)  // Output: true
//
//        odd := is.Even(7)
//        fmt.Println(odd)  // Output: false
//
//        floatingPoint := is.Even(6.6)
//        fmt.Println(floatingPoint)  // Output: false
//
//        floatingPoint = is.Even(6.6, true)
//        fmt.Println(floatingPoint)  // Output: true
func Even[T Numerable](v T, f ...bool) bool <span class="cov8" title="1">{
        return g.IsEven(v, f...)
}</span>

// Odd checks if a value is an odd number.
//
// The function accepts a value of any type T that satisfies
// the Numerable interface. If the `f` argument is provided
// and set to true, the function ignores the fractional part
// of the value when checking for oddness. For integer types,
// it checks if the value is not divisible by 2 without a remainder.
// For floating-point types, it considers only the integer part
// of the value and determines the parity of the integer part.
// If the value has a non-zero fractional part and `f` is true,
// it returns true since an odd number cannot have a fractional part.
// Otherwise, it returns the negation of the IsEven function.
//
// Example usage:
//
//        odd := is.Odd(7)
//        fmt.Println(odd)  // Output: true
//
//        even := is.Odd(6)
//        fmt.Println(even)  // Output: false
//
//        floatingPoint := is.Odd(7.7)
//        fmt.Println(floatingPoint)  // Output: false
//
//        floatingPoint = is.Odd(7.7, true)
//        fmt.Println(floatingPoint)  // Output: true
func Odd[T Numerable](v T, f ...bool) bool <span class="cov8" title="1">{
        return g.IsOdd(v, f...)
}</span>

// Whole checks if a value is a whole number.
//
// The function accepts a value of any type T that satisfies
// the Numerable interface. It first checks if the value has
// a non-zero fractional part. If it does, it returns false
// since a whole number cannot have a fractional part.
// If the value does not have a fractional part, it returns true.
//
// Example usage:
//
//        whole := is.Whole(5)
//        fmt.Println(whole)  // Output: true
//
//        notWhole := is.Whole(5.5)
//        fmt.Println(notWhole)  // Output: false
//
//        zero := is.Whole(0)
//        fmt.Println(zero)  // Output: true
//
//        negative := is.Whole(-3)
//        fmt.Println(negative)  // Output: true
func Whole[T Numerable](v T) bool <span class="cov8" title="1">{
        return g.IsWhole(v)
}</span>

// Negative verifies if the numerable value v is less than zero.
// The function uses generic type T, which must satisfy the Numerable
// type constraint. This function is useful for validating the sign of
// numerical data.
//
// Example usage:
//
//        is.Negative(5)      // Output: false
//        is.Negative(-5)     // Output: true
//        is.Negative(0)      // Output: false
//        is.Negative(3.14)   // Output: false
//        is.Negative(-3.14)  // Output: true
//
// Please note that zero is neither positive nor negative. It lies
// between positive and negative numbers on the number line and does
// not change the value of another number when it is added to or
// subtracted from it.
func Negative[T Numerable](v T) bool <span class="cov8" title="1">{
        return v &lt; 0
}</span>

// Positive verifies if the numerable value v is greater than zero.
// The function uses generic type T, which must satisfy the Numerable
// type constraint. This function is useful for validating the sign of
// numerical data.
//
// Example usage:
//
//        is.Positive(5)      // Output: true
//        is.Positive(-5)     // Output: false
//        is.Positive(0)      // Output: false
//        is.Positive(3.14)   // Output: true
//        is.Positive(-3.14)  // Output: false
//
// Please note that zero is neither positive nor negative. It lies
// between positive and negative numbers on the number line and does
// not change the value of another number when it is added to or
// subtracted from it.
func Positive[T Numerable](v T) bool <span class="cov8" title="1">{
        return v &gt; 0
}</span>

// Zero checks if the numerable value v is equal to zero.
// The function uses generic type T, which must satisfy the Numerable
// type constraint. This function is useful for validating whether the
// numerical data equals zero.
//
// Example usage:
//
//        is.Zero(5)      // Output: false
//        is.Zero(-5)     // Output: false
//        is.Zero(0)      // Output: true
//        is.Zero(3.14)   // Output: false
//        is.Zero(-3.14)  // Output: false
//
// Please note that zero is a unique number that is neither positive
// nor negative. It lies between positive and negative numbers on the
// number line and does not change the value of another number when it
// is added to or subtracted from it.
func Zero[T Numerable](v T) bool <span class="cov8" title="1">{
        return v == 0
}</span>

// Natural checks if the numerable value v is a natural number.
// A natural number is a positive integer starting from 1. Zero is not
// considered a natural number. The function uses generic type T, which
// must satisfy the Numerable type constraint.
//
// Example usage:
//
//        is.Natural(5)      // Output: true
//        is.Natural(5.0)    // Output: true
//        is.Natural(-5)     // Output: false
//        is.Natural(0)      // Output: false
//        is.Natural(3.14)   // Output: false
//
// Please note that this function checks if the value is a whole number
// and is positive.
func Natural[T Numerable](v T) bool <span class="cov8" title="1">{
        return Whole(v) &amp;&amp; Positive(v)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package is

import (
        "fmt"
        "regexp"
        "strconv"

        "github.com/goloop/g"
)

var (
        // The e16Regex is regular expression for E.164.
        e164Regex = regexp.MustCompile(`^\+\d{1,15}$`)

        // The phoneRegex regular expression for phone number.
        phoneRegex = regexp.MustCompile(`^\+[\d]+$`)
)

// IMSI checks if the given value is a valid International Mobile Subscriber
// Identity (IMSI). The IMSI is a unique identifier associated with a mobile
// network subscriber. It consists of three parts: MCC (Mobile Country Code),
// MNC (Mobile Network Code), and MSIN (Mobile Subscriber Identification
// Number).
//
// This function validates the IMSI by performing the following checks:
// 1. The length of the IMSI should be 15 digits.
// 2. The first three digits (MCC) should be a valid MCC.
// 3. The following two or three digits (MNC) should be a valid MNC.
// 4. The remaining digits (MSIN) should be numeric.
//
// Example usage:
//
//        is.IMSI("310150123456789")  // Returns: true
//        is.IMSI("460001234567890")  // Returns: true
//        is.IMSI("1234567890123456") // Returns: false, length exceeds 15 digits
//        is.IMSI("310150abc123456")  // Returns: false, invalid characters in MSIN
func IMSI(imsi string) bool <span class="cov8" title="1">{
        // Check the length of the IMSI.
        if len(imsi) != 15 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check the first three digits (MCC).
        <span class="cov8" title="1">mccStr := imsi[:3]
        _, err := strconv.Atoi(mccStr)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check the next two or three digits (MNC).
        <span class="cov8" title="1">mncStr := imsi[3:5]
        _, err = strconv.Atoi(mncStr)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check the remaining digits (MSIN).
        <span class="cov8" title="1">msinStr := imsi[5:]
        if _, err := strconv.Atoi(msinStr); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// IMEI validates whether a given string is a valid International Mobile
// Equipment Identity (IMEI). It uses the Luhn algorithm for verification.
//
// The value cannot contain characters other than numbers.
//
// The function takes as input a string 'v' representing a potential IMEI
// number, which could include spaces, dots, hyphens, or newline characters
// as separators. These are removed from the input string to obtain the raw
// number.
//
// The Luhn algorithm is then applied to this raw number to check its validity.
// This involves iterating over each digit in the number. If the digit is
// at an even-indexed position in the string (where the first position is
// considered index 1), its value is added directly to a running sum.
// If the digit is at an odd-indexed position, it is doubled.
// If the result of this doubling is greater than 9, 9 is subtracted from it.
// This resultant value is then added to the sum.
//
// After all digits have been processed, the function checks if the total
// sum is a multiple of 10. If it is, the function returns true, indicating
// that the input string is a valid IMEI.
// Otherwise, it returns false.
//
// Example usage:
//
//        is.IMEI("522593572995861") // Returns: true
//        is.IMEI("532593572995861") // Returns: false
//
// Note: An IMEI number is a unique identifier assigned to each mobile device.
// It is a 15-digit number used for tracking and identifying the device.
// The last digit is a check digit, computed according to the Luhn algorithm.
func IMEI[T string | int64](imei T) bool <span class="cov8" title="1">{
        v := fmt.Sprint(imei)
        if len(v) != 15 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">sum := 0
        for i := 0; i &lt; len(v); i++ </span><span class="cov8" title="1">{
                digit, _ := strconv.Atoi(string(v[i]))

                // If the digit is in an even-indexed position (where the
                // first position is 1), double its value.
                if i%2 == 0 </span><span class="cov8" title="1">{
                        sum += digit
                }</span> else<span class="cov8" title="1"> {
                        digit *= 2
                        if digit &gt; 9 </span><span class="cov8" title="1">{
                                digit -= 9
                        }</span>
                        <span class="cov8" title="1">sum += digit</span>
                }
        }

        // Check if the total sum is a multiple of 10.
        // If it is, then the IMEI is valid.
        <span class="cov8" title="1">return sum%10 == 0</span>
}

// E164 checks if the string is a valid representation of a phone number
// according to the E.164 standard.
//
// The E.164 standard defines a numbering plan for the international
// public telecommunication numbering system. It specifies the format
// for international phone numbers and assigns a unique number to each
// country or region.
//
// This function uses a regular expression to match the input string against
// the E.164 phone number pattern. The pattern requires the string to start
// with a plus sign (+) followed by one or more digits. It allows a maximum
// length of 15 digits (excluding the plus sign).
//
// Example usage:
//
//        is.E164("+123456789")   // Returns: true
//        is.E164("+0123456789")  // Returns: true
//        is.E164("+")            // Returns: false, no digits after plus sign
//        is.E164("+1234567890a") // Returns: false, non-digit character
//        is.E164("1234567890")   // Returns: false, no plus sign
//        is.E164("")             // Returns: false, empty string
//
// This function can be used to validate user input or data to ensure
// it follows the E.164 standard for phone numbers.
func E164(v string) bool <span class="cov8" title="1">{
        return e164Regex.MatchString(v)
}</span>

// Phone checks if the given string is a valid phone number.
// The phone number can have the following format:
// - It starts with a plus sign (+) followed by the country code.
// - The country code can be enclosed in parentheses.
// - The phone number can contain spaces between digits.
//
// Example usage:
//
//        is.Phone("+380 (96) 00 00 000") // Returns: true
//        is.Phone("+380961234567")       // Returns: true
//        is.Phone("123456789")           // Returns: false, no plus sign
//        is.Phone("")                    // Returns: false, empty string
//
// This function can be used to validate user input or data to ensure
// it follows the specified format for phone numbers.
func Phone(phone string) bool <span class="cov8" title="1">{
        return phoneRegex.MatchString(g.Weed(phone, " ()"))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package is

import (
        "strings"
        "unicode"
)

// The numbers is a map of all Unicode code points that
// are classified as "Numbers".
var numbers = map[rune]struct{}{
        // Arabic numerals.
        '0': {}, '1': {}, '2': {}, '3': {}, '4': {},
        '5': {}, '6': {}, '7': {}, '8': {}, '9': {},

        // Fullwidth Arabic numerals.
        '０': {}, '１': {}, '２': {}, '３': {}, '４': {},
        '５': {}, '６': {}, '７': {}, '８': {}, '９': {},

        // Arabic-Indic numerals.
        '٠': {}, '١': {}, '٢': {}, '٣': {}, '٤': {},
        '٥': {}, '٦': {}, '٧': {}, '٨': {}, '٩': {},

        // Extended Arabic-Indic numerals.
        // Persian numerals.
        '۰': {}, '۱': {}, '۲': {}, '۳': {}, '۴': {},
        '۵': {}, '۶': {}, '۷': {}, '۸': {}, '۹': {},

        // Devanagari numerals.
        '०': {}, '१': {}, '२': {}, '३': {}, '४': {},
        '५': {}, '६': {}, '७': {}, '८': {}, '९': {},

        // Bengali numerals.
        '০': {}, '১': {}, '২': {}, '৩': {}, '৪': {},
        '৫': {}, '৬': {}, '৭': {}, '৮': {}, '৯': {},

        // Chinese numerals.
        '零': {}, '一': {}, '二': {}, '三': {}, '四': {},
        '五': {}, '六': {}, '七': {}, '八': {}, '九': {},
        '十': {}, '廿': {}, '卅': {}, '卌': {}, '百': {},
        '千': {}, '万': {}, '億': {}, '兆': {}, '京': {},
        '雲': {}, '穣': {}, '拾': {}, '佰': {}, '仟': {},
        '萬': {}, '垓': {}, '秭': {}, '穰': {},

        // Japanese numerals.
        '〇': {}, '壱': {}, '弐': {}, '参': {},

        // Korean numerals.
        '영': {}, '일': {}, '이': {}, '삼': {}, '사': {},
        '오': {}, '육': {}, '칠': {}, '팔': {}, '구': {},
        '십': {}, '백': {}, '천': {}, '만': {},
        '억': {}, '조': {},

        // Gujarati numerals.
        '૦': {}, '૧': {}, '૨': {}, '૩': {}, '૪': {},
        '૫': {}, '૬': {}, '૭': {}, '૮': {}, '૯': {},

        // Punjabi (Gurmukhi) numerals.
        '੦': {}, '੧': {}, '੨': {}, '੩': {}, '੪': {},
        '੫': {}, '੬': {}, '੭': {}, '੮': {}, '੯': {},

        // Tamil numerals.
        '௦': {}, '௧': {}, '௨': {}, '௩': {}, '௪': {},
        '௫': {}, '௬': {}, '௭': {}, '௮': {}, '௯': {},

        // Telugu numerals.
        '౦': {}, '౧': {}, '౨': {}, '౩': {}, '౪': {},
        '౫': {}, '౬': {}, '౭': {}, '౮': {}, '౯': {},

        // Kannada numerals.
        '೦': {}, '೧': {}, '೨': {}, '೩': {}, '೪': {},
        '೫': {}, '೬': {}, '೭': {}, '೮': {}, '೯': {},

        // Malayalam numerals.
        '൦': {}, '൧': {}, '൨': {}, '൩': {}, '൪': {},
        '൫': {}, '൬': {}, '൭': {}, '൮': {}, '൯': {},

        // Thai numerals.
        '๐': {}, '๑': {}, '๒': {}, '๓': {}, '๔': {},
        '๕': {}, '๖': {}, '๗': {}, '๘': {}, '๙': {},

        // Lao numerals.
        '໐': {}, '໑': {}, '໒': {}, '໓': {}, '໔': {},
        '໕': {}, '໖': {}, '໗': {}, '໘': {}, '໙': {},

        // Tibetan numerals.
        '༠': {}, '༡': {}, '༢': {}, '༣': {}, '༤': {},
        '༥': {}, '༦': {}, '༧': {}, '༨': {}, '༩': {},

        // Myanmar (Burmese) numerals.
        '၀': {}, '၁': {}, '၂': {}, '၃': {}, '၄': {},
        '၅': {}, '၆': {}, '၇': {}, '၈': {}, '၉': {},

        // Khmer numerals.
        '០': {}, '១': {}, '២': {}, '៣': {}, '៤': {},
        '៥': {}, '៦': {}, '៧': {}, '៨': {}, '៩': {},

        // Hebrew numerals.
        'א': {}, 'ב': {}, 'ג': {}, 'ד': {},
        'ה': {}, 'ו': {}, 'ז': {}, 'ח': {}, 'ט': {},
        'י': {}, 'כ': {}, 'ל': {}, 'מ': {},
        'נ': {}, 'ס': {}, 'ע': {}, 'פ': {}, 'צ': {},
        'ק': {}, 'ר': {}, 'ש': {}, 'ת': {},
        'ך': {}, 'ם': {}, 'ן': {}, 'ף': {}, 'ץ': {},

        // Balinese numerals.
        '᭐': {}, '᭑': {}, '᭒': {}, '᭓': {}, '᭔': {},
        '᭕': {}, '᭖': {}, '᭗': {}, '᭘': {}, '᭙': {},

        // Limbu numerals.
        '᥆': {}, '᥇': {}, '᥈': {}, '᥉': {}, '᥊': {},
        '᥋': {}, '᥌': {}, '᥍': {}, '᥎': {}, '᥏': {},

        // Osmanya numerals.
        '𐒠': {}, '𐒡': {}, '𐒢': {}, '𐒣': {}, '𐒤': {},
        '𐒥': {}, '𐒦': {}, '𐒧': {}, '𐒨': {}, '𐒩': {},

        // Saurashtra numerals.
        '꣠': {}, '꣡': {}, '꣢': {}, '꣣': {}, '꣤': {},
        '꣥': {}, '꣦': {}, '꣧': {}, '꣨': {}, '꣩': {},

        // Sundanese numerals.
        '᮰': {}, '᮱': {}, '᮲': {}, '᮳': {}, '᮴': {},
        '᮵': {}, '᮶': {}, '᮷': {}, '᮸': {}, '᮹': {},

        // Javanese numerals.
        '꧐': {}, '꧑': {}, '꧒': {}, '꧓': {}, '꧔': {},
        '꧕': {}, '꧖': {}, '꧗': {}, '꧘': {}, '꧙': {},

        // Old Persian numerals.
        '𐏐': {}, '𐏑': {}, '𐏒': {}, '𐏓': {}, '𐏔': {},

        // Armenian numerals.
        'Ա': {}, 'Բ': {}, 'Գ': {}, 'Դ': {}, 'Ե': {}, 'Զ': {},
        'Է': {}, 'Ը': {}, 'Թ': {}, 'Ժ': {}, 'Ի': {}, 'Լ': {},
        'Խ': {}, 'Ծ': {}, 'Կ': {}, 'Հ': {}, 'Ձ': {}, 'Ղ': {},
        'Ճ': {}, 'Մ': {}, 'Յ': {}, 'Ն': {}, 'Շ': {}, 'Ո': {},
        'Չ': {}, 'Պ': {}, 'Ջ': {}, 'Ռ': {}, 'Ս': {}, 'Վ': {},
        'Տ': {}, 'Ր': {}, 'Ց': {}, 'Ւ': {}, 'Փ': {}, 'Ք': {},

        // Mongolian numerals.
        '᠑': {}, '᠒': {}, '᠓': {}, '᠔': {}, '᠕': {}, '᠖': {},
        '᠗': {}, '᠘': {}, '᠙': {}, '᠐': {}, 'ᠠ': {}, 'ᠡ': {},
        'ᠢ': {}, 'ᠣ': {}, 'ᠤ': {}, 'ᠥ': {},

        // Brahmi numerals.
        '𑁒': {}, '𑁓': {}, '𑁔': {}, '𑁕': {}, '𑁖': {}, '𑁗': {}, '𑁘': {},
        '𑁙': {}, '𑁚': {}, '𑁛': {}, '𑁜': {}, '𑁝': {}, '𑁞': {}, '𑁟': {},
        '𑁠': {}, '𑁡': {}, '𑁢': {}, '𑁣': {}, '𑁤': {}, '𑁥': {},

        // Ancient Greek numerals.
        'Α': {}, 'Β': {}, 'Γ': {}, 'Δ': {}, 'Ε': {}, 'Ϛ': {}, 'Ζ': {},
        'Η': {}, 'Θ': {}, 'Ι': {}, 'Κ': {}, 'Λ': {}, 'Μ': {}, 'Ν': {},
        'Ξ': {}, 'Ο': {}, 'Π': {}, 'Ϟ': {}, 'Ϡ': {}, 'ϡ': {}, 'Ϣ': {},
        'ϣ': {}, 'Ϥ': {}, 'ϥ': {}, 'Ϧ': {}, 'ϧ': {}, 'Ϩ': {}, 'ϩ': {},
        'Ϫ': {}, 'ϫ': {}, 'Ϭ': {}, 'ϭ': {}, 'Ϯ': {}, 'ϯ': {}, 'ϰ': {},
        'ϱ': {}, 'ϲ': {}, 'ϳ': {}, 'ϴ': {}, 'ϵ': {}, '϶': {}, 'Ϸ': {},
        'ϸ': {}, 'Ϻ': {}, 'ϻ': {},

        // Coptic numerals.
        'Ⲁ': {}, 'Ⲃ': {}, 'Ⲅ': {}, 'Ⲇ': {}, 'Ⲉ': {}, 'Ⲋ': {}, 'Ⲍ': {},
        'Ⲏ': {}, 'Ⲑ': {}, 'Ⲓ': {}, 'Ⲕ': {}, 'Ⲗ': {}, 'Ⲙ': {}, 'Ⲛ': {},
        'Ⲝ': {}, 'Ⲟ': {}, 'Ⲡ': {}, 'Ⲣ': {}, '⳰': {}, 'Ⳳ': {}, '⳴': {},
        '⳶': {}, '⳼': {}, '⳾': {}, '⳿': {},

        // Ethiopic numerals.
        '፩': {}, '፪': {}, '፫': {}, '፬': {}, '፭': {}, '፮': {},
        '፯': {}, '፰': {}, '፱': {}, '፲': {}, '፳': {}, '፴': {},
        '፵': {}, '፶': {}, '፷': {}, '፸': {}, '፹': {}, '፺': {},
        '፻': {}, '፼': {},
}

// Digit checks whether a string consists only of numbers.
//
// This method returns true if all characters in the string are numbers and
// the string is not empty. This includes digits (0-9), numeric characters
// that have a specific meaning in non-positional number systems (such as
// base 2, 8, or 16 number systems), and Unicode digit characters.
//
// Example usage:
//
//        is.Digit("1234")     // Output: true
//        is.Digit("Ⅳ")       // Output: false
//        is.Digit("1234abc")  // Output: false
func Digit(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsDigit(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Numeric checks whether a string consists only of numeric characters,
// including digits, decimal separators, and an optional '+' or '-' sign at the beginning.
// The function recognizes integers and floating-point numbers, as well as
// digits from various numeral systems and scripts.
//
// Returns true if all characters in the string are numeric, and false otherwise.
// The function supports decimal separators from different cultures.
//
// Example usage:
//
//        is.Numeric("1234")     // Output: true
//        is.Numeric("3.14")     // Output: true
//        is.Numeric("-456,789") // Output: true (if comma is considered a separator)
//        is.Numeric("Ⅳ")       // Output: true
//        is.Numeric("三・十四")  // Output: true
//        is.Numeric("1234abc")  // Output: false
//        is.Numeric("1.2.3")    // Output: false (more than one decimal separator)
func Numeric(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var (
                hasDecimalSeparator bool
                decimalSeparators   = map[rune]struct{}{
                        '.': {}, // Dot
                        ',': {}, // Comma
                        '·': {}, // Middle dot
                        '・': {}, // Japanese separator
                        '٫': {}, // Arabic decimal point
                        '،': {}, // Arabic comma
                        '۔': {}, // Urdu decimal point
                }
        )

        for i, r := range s </span><span class="cov8" title="1">{
                // Check if the first character is a sign.
                if i == 0 &amp;&amp; (r == '+' || r == '-') </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if the character is a decimal separator.
                <span class="cov8" title="1">if _, isSeparator := decimalSeparators[r]; isSeparator </span><span class="cov8" title="1">{
                        if hasDecimalSeparator </span><span class="cov0" title="0">{
                                return false // more than one decimal separator
                        }</span>
                        <span class="cov8" title="1">hasDecimalSeparator = true
                        continue</span>
                }

                // Check if the character is a number.
                <span class="cov8" title="1">if !unicode.IsDigit(r) &amp;&amp; !unicode.Is(unicode.Number, r) </span><span class="cov8" title="1">{
                        if _, ok := numbers[r]; !ok </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// Decimal returns true if all characters in the string are decimal digits
// and the string is not empty. Decimal digits are only the characters with
// the numbers 0 through 9. It does not recognize any other numeric characters
// such as Roman numerals or digits from non-positional number systems.
//
// Example usage:
//
//        is.Decimal("1234")     // Output: true
//        is.Decimal("Ⅳ")       // Output: false
//        is.Decimal("1234abc")  // Output: false
//        is.Decimal("1234.56")  // Output: false
func Decimal(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Float returns true if the string represents a floating-point number,
// where the decimal separator is a dot, and all digits are ASCII digits (0-9).
// It supports an optional '+' or '-' sign at the beginning and at most one
// decimal point. It does not support exponential notation or other numeric
// formats.
//
// Example usage:
//
//        is.Float("123.456")     // Output: true
//        is.Float("-0.001")      // Output: true
//        is.Float("3.14")        // Output: true
//        is.Float("123")         // Output: true
//        is.Float("123.")        // Output: true
//        is.Float(".456")        // Output: true
//        is.Float("123.456.789") // Output: false
//        is.Float("abc")         // Output: false
//        is.Float("123a")        // Output: false
//        is.Float("123,456")     // Output: false
func Float(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var (
                hasDecimalPoint bool
                hasDigits       bool
                startIndex      int
        )

        // Check for optional sign at the beginning.
        if s[0] == '+' || s[0] == '-' </span><span class="cov8" title="1">{
                startIndex = 1
        }</span>

        // Edge case: string contains only '+' or '-'.
        <span class="cov8" title="1">if startIndex &gt;= len(s) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i := startIndex; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                r := rune(s[i])

                if r == '.' </span><span class="cov8" title="1">{
                        if hasDecimalPoint </span><span class="cov8" title="1">{
                                return false // more than one decimal point
                        }</span>
                        <span class="cov8" title="1">hasDecimalPoint = true
                        continue</span>
                }

                <span class="cov8" title="1">if r &gt;= '0' &amp;&amp; r &lt;= '9' </span><span class="cov8" title="1">{
                        hasDigits = true
                        continue</span>
                }

                <span class="cov8" title="1">return false</span>
        }

        // At least one digit is required.
        <span class="cov8" title="1">return hasDigits</span>
}

// Alpha checks whether a string consists only of alphabetic
// characters (letters). It does not recognize digits, special
// characters.
//
// Example usage:
//
//        is.Alpha("Київ")  // Output: true
//        is.Alpha("abc")   // Output: true
//        is.Alpha("abc1")  // Output: false, contains a digit
//        is.Alpha("abc!")  // Output: false, contains a special character
//        is.Alpha("abcΔ")  // Output: false, contains a non-Latin letter
func Alpha(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsLetter(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Alnum checks whether a string consists only of alphabetic
// characters (letters) and numbers.
//
// Example usage:
//
//        is.Alnum("abc123")      // Output: true
//        is.Alnum("abc")         // Output: true
//        is.Alnum("123")         // Output: true
//        is.Alnum("abc!")        // Output: false
//        is.Alnum("abcΔ")        // Output: false
func Alnum(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Lower checks whether a string consists only of lowercase
// alphabetic characters.
//
// Example usage:
//
//        is.Lower("abc")       // Output: true
//        is.Lower("Abc")       // Output: false, contains an uppercase letter
//        is.Lower("abc123")    // Output: false, contains a number
//        is.Lower("abc!")      // Output: false, contains a special character
func Lower(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsLower(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Upper checks whether a string consists only of uppercase
// alphabetic characters.
//
// Example usage:
//
//        is.Upper("ABC")      // Output: true
//        is.Upper("AbC")      // Output: false, contains a lowercase letter
//        is.Upper("ABC123")   // Output: false, contains a number
//        is.Upper("ABC!")     // Output: false, contains a special character
func Upper(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsUpper(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Title checks whether a string is a titlecased string.
//
// In a titlecased string, upper- and title-case characters may only
// follow uncased characters and lowercase characters only cased ones.
//
// Example usage:
//
//        is.Title("Hello World")   // Output: true
//        is.Title("Hello world")   // Output: false, 'world' starts with a lowercase
//        is.Title("HELLO WORLD")   // Output: false, all letters are uppercase
//        is.Title("hELLO wORLD")   // Output: false, words start with a lowercase
func Title(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">words := strings.FieldsFunc(s, func(r rune) bool </span><span class="cov8" title="1">{
                return !unicode.IsLetter(r)
        }</span>)

        <span class="cov8" title="1">for _, word := range words </span><span class="cov8" title="1">{
                for index, char := range word </span><span class="cov8" title="1">{
                        if index == 0 </span><span class="cov8" title="1">{
                                if !unicode.IsUpper(char) </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if !unicode.IsLower(char) </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return true</span>
}

// Space checks whether a string consists only of whitespace characters.
// Whitespace characters includes spaces, tabs, newlines, and other
// Unicode whitespace characters.
//
// Example usage:
//
//        is.Space(" \t\n")    // Output: true
//        is.Space("Hello")    // Output: false
//        is.Space(" ")        // Output: true
//        is.Space("\n\t ")    // Output: true
//        is.Space("")         // Output: false, an empty string has no characters
func Space(s string) bool <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                if !unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
